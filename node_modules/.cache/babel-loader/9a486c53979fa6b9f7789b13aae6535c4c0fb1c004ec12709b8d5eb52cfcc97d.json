{"ast":null,"code":"var _s = $RefreshSig$();\n/*\n  src/hooks/useOCR.js\n  Provides a simple wrapper around Tesseract.js for client-side OCR.\n  Exposes `recognize(file)` which returns the recognized text and bounding boxes.\n*/\nimport { useState } from 'react';\nimport { createWorker } from 'tesseract.js';\nexport function useOCR() {\n  _s();\n  const [recognizing, setRecognizing] = useState(false);\n  const [resultText, setResultText] = useState('');\n  const [boxes, setBoxes] = useState([]);\n  const recognize = async file => {\n    setRecognizing(true);\n    try {\n      const worker = await createWorker({\n        logger: m => {}\n      });\n      await worker.load();\n      await worker.loadLanguage('eng');\n      await worker.initialize('eng');\n      // restrict to digits and whitespace to improve accuracy on numbers\n      await worker.setParameters({\n        tessedit_char_whitelist: '0123456789\\n ,.'\n      });\n      if (opts && opts.psm) {\n        await worker.setParameters({\n          tessedit_pageseg_mode: String(opts.psm)\n        });\n      }\n      const {\n        data\n      } = await worker.recognize(file);\n      setResultText(data.text);\n      // Extract bounding boxes for words\n      const wordBoxes = data.words.map(word => ({\n        text: word.text.trim(),\n        bbox: word.bbox,\n        conf: word.confidence\n      })).filter(box => box.text && /^\\d+$/.test(box.text)); // only numeric words\n\n      // Try to produce finer-grained tokens from symbols (characters)\n      const digits = (data.symbols || []).filter(s => s.text && /\\d/.test(s.text)).map(s => ({\n        ch: s.text,\n        bbox: s.bbox\n      }));\n      const tokens = [];\n      digits.sort((a, b) => a.bbox.y0 - b.bbox.y0 || a.bbox.x0 - b.bbox.x0);\n      const gapFactor = 1.6;\n      let cur = null;\n      for (const d of digits) {\n        if (!cur) {\n          cur = {\n            text: d.ch,\n            bbox: Object.assign({}, d.bbox)\n          };\n          continue;\n        }\n        const vertOverlap = Math.min(cur.bbox.y1, d.bbox.y1) - Math.max(cur.bbox.y0, d.bbox.y0);\n        const avgH = (cur.bbox.y1 - cur.bbox.y0 + (d.bbox.y1 - d.bbox.y0)) / 2;\n        if (vertOverlap >= avgH * 0.25) {\n          const gap = d.bbox.x0 - cur.bbox.x1;\n          const avgW = (cur.bbox.x1 - cur.bbox.x0 + (d.bbox.x1 - d.bbox.x0)) / 2;\n          if (gap <= avgW * gapFactor) {\n            cur.text += d.ch;\n            cur.bbox.x1 = Math.max(cur.bbox.x1, d.bbox.x1);\n            cur.bbox.y0 = Math.min(cur.bbox.y0, d.bbox.y0);\n            cur.bbox.y1 = Math.max(cur.bbox.y1, d.bbox.y1);\n            continue;\n          }\n        }\n        tokens.push(cur);\n        cur = {\n          text: d.ch,\n          bbox: Object.assign({}, d.bbox)\n        };\n      }\n      if (cur) tokens.push(cur);\n      const numericTokens = tokens.filter(t => t.text && /^\\d+$/.test(t.text)).map(t => ({\n        text: t.text,\n        bbox: t.bbox\n      }));\n      setBoxes(wordBoxes);\n      await worker.terminate();\n      return {\n        text: data.text,\n        boxes: wordBoxes,\n        tokens: numericTokens\n      };\n    } catch (err) {\n      setResultText('');\n      setBoxes([]);\n      console.error('OCR error', err);\n      return {\n        text: '',\n        boxes: []\n      };\n    } finally {\n      setRecognizing(false);\n    }\n  };\n  return {\n    recognizing,\n    resultText,\n    boxes,\n    recognize\n  };\n}\n_s(useOCR, \"JIgR99/IGbmXnkQ9NyH2qRHxusY=\");","map":{"version":3,"names":["useState","createWorker","useOCR","_s","recognizing","setRecognizing","resultText","setResultText","boxes","setBoxes","recognize","file","worker","logger","m","load","loadLanguage","initialize","setParameters","tessedit_char_whitelist","opts","psm","tessedit_pageseg_mode","String","data","text","wordBoxes","words","map","word","trim","bbox","conf","confidence","filter","box","test","digits","symbols","s","ch","tokens","sort","a","b","y0","x0","gapFactor","cur","d","Object","assign","vertOverlap","Math","min","y1","max","avgH","gap","x1","avgW","push","numericTokens","t","terminate","err","console","error"],"sources":["C:/Users/Rande/bingocaller/src/hooks/useOCR.js"],"sourcesContent":["/*\n  src/hooks/useOCR.js\n  Provides a simple wrapper around Tesseract.js for client-side OCR.\n  Exposes `recognize(file)` which returns the recognized text and bounding boxes.\n*/\nimport { useState } from 'react'\nimport { createWorker } from 'tesseract.js'\n\nexport function useOCR(){\n  const [recognizing, setRecognizing] = useState(false)\n  const [resultText, setResultText] = useState('')\n  const [boxes, setBoxes] = useState([])\n\n  const recognize = async (file) => {\n    setRecognizing(true)\n    try {\n      const worker = await createWorker({ logger: m => {} })\n      await worker.load()\n      await worker.loadLanguage('eng')\n      await worker.initialize('eng')\n      // restrict to digits and whitespace to improve accuracy on numbers\n      await worker.setParameters({ tessedit_char_whitelist: '0123456789\\n ,.' })\n      if (opts && opts.psm) {\n        await worker.setParameters({ tessedit_pageseg_mode: String(opts.psm) })\n      }\n      const { data } = await worker.recognize(file)\n      setResultText(data.text)\n      // Extract bounding boxes for words\n      const wordBoxes = data.words.map(word => ({\n        text: word.text.trim(),\n        bbox: word.bbox,\n        conf: word.confidence\n      })).filter(box => box.text && /^\\d+$/.test(box.text)) // only numeric words\n\n      // Try to produce finer-grained tokens from symbols (characters)\n      const digits = (data.symbols || []).filter(s => s.text && /\\d/.test(s.text)).map(s => ({ ch: s.text, bbox: s.bbox }))\n      const tokens = []\n      digits.sort((a,b)=> (a.bbox.y0 - b.bbox.y0) || (a.bbox.x0 - b.bbox.x0))\n      const gapFactor = 1.6\n      let cur = null\n      for (const d of digits) {\n        if (!cur) { cur = { text: d.ch, bbox: Object.assign({}, d.bbox) }; continue }\n        const vertOverlap = Math.min(cur.bbox.y1, d.bbox.y1) - Math.max(cur.bbox.y0, d.bbox.y0)\n        const avgH = ( (cur.bbox.y1-cur.bbox.y0) + (d.bbox.y1-d.bbox.y0) )/2\n        if (vertOverlap >= avgH * 0.25) {\n          const gap = d.bbox.x0 - cur.bbox.x1\n          const avgW = ( (cur.bbox.x1-cur.bbox.x0) + (d.bbox.x1-d.bbox.x0) )/2\n          if (gap <= avgW * gapFactor) {\n            cur.text += d.ch\n            cur.bbox.x1 = Math.max(cur.bbox.x1, d.bbox.x1)\n            cur.bbox.y0 = Math.min(cur.bbox.y0, d.bbox.y0)\n            cur.bbox.y1 = Math.max(cur.bbox.y1, d.bbox.y1)\n            continue\n          }\n        }\n        tokens.push(cur)\n        cur = { text: d.ch, bbox: Object.assign({}, d.bbox) }\n      }\n      if (cur) tokens.push(cur)\n\n      const numericTokens = tokens.filter(t => t.text && /^\\d+$/.test(t.text)).map(t => ({ text: t.text, bbox: t.bbox }))\n\n      setBoxes(wordBoxes)\n      await worker.terminate()\n      return { text: data.text, boxes: wordBoxes, tokens: numericTokens }\n    } catch (err) {\n      setResultText('')\n      setBoxes([])\n      console.error('OCR error', err)\n      return { text: '', boxes: [] }\n    } finally {\n      setRecognizing(false)\n    }\n  }\n\n  return { recognizing, resultText, boxes, recognize }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}