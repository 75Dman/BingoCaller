{"ast":null,"code":"/*\r\n  src/utils/smartFill.js\r\n  Infer a regular grid from OCR tokens and try to fill missing numbers by\r\n  detecting a linear pattern across the flattened grid (row-major or column-major).\r\n  Exports: inferAndFill(tokens, opts)\r\n\r\n  tokens: [{ text: '23', bbox: { x0,y0,x1,y1 } }, ... ] in image pixel coords\r\n  opts: { expectedRows?, expectedCols?, minAllowed?, maxAllowed? }\r\n  Returns: { rows: [[num|null,...],...], cellBoxes: [[{x0,y0,x1,y1},...],...], orientation, filledCount }\r\n*/\n\nfunction cluster1d(values, gapFactor = 1.5) {\n  if (!values.length) return [];\n  const s = [...values].sort((a, b) => a - b);\n  const diffs = [];\n  for (let i = 1; i < s.length; i++) diffs.push(s[i] - s[i - 1]);\n  const medianDiff = diffs.length ? diffs.sort((a, b) => a - b)[Math.floor(diffs.length / 2)] : 0;\n  const thresh = Math.max(1, medianDiff * gapFactor);\n  const groups = [];\n  let cur = [s[0]];\n  for (let i = 1; i < s.length; i++) {\n    if (s[i] - s[i - 1] > thresh) {\n      groups.push(cur);\n      cur = [s[i]];\n    } else cur.push(s[i]);\n  }\n  if (cur.length) groups.push(cur);\n  return groups.map(g => g.reduce((a, b) => a + b, 0) / g.length);\n}\nfunction computeGridCenters(tokens, opts = {}) {\n  const pts = tokens.map(t => ({\n    text: t.text,\n    cx: (t.bbox.x0 + t.bbox.x1) / 2,\n    cy: (t.bbox.y0 + t.bbox.y1) / 2\n  }));\n  if (!pts.length) return null;\n  const xs = pts.map(p => p.cx);\n  const ys = pts.map(p => p.cy);\n  const colCenters = cluster1d(xs, 1.2);\n  const rowCenters = cluster1d(ys, 1.2);\n  return {\n    rowCenters,\n    colCenters,\n    pts\n  };\n}\nfunction makeEmptyGrid(rows, cols) {\n  return Array.from({\n    length: rows\n  }, () => Array.from({\n    length: cols\n  }, () => null));\n}\nfunction assignTokensToGrid(tokens, rowCenters, colCenters) {\n  const rows = rowCenters.length,\n    cols = colCenters.length;\n  const grid = makeEmptyGrid(rows, cols);\n  const cells = Array.from({\n    length: rows\n  }, () => Array.from({\n    length: cols\n  }, () => null));\n  for (const t of tokens) {\n    const cx = (t.bbox.x0 + t.bbox.x1) / 2;\n    const cy = (t.bbox.y0 + t.bbox.y1) / 2;\n    // find nearest col/row\n    let c = 0,\n      cd = Math.abs(cx - colCenters[0]);\n    for (let i = 1; i < colCenters.length; i++) {\n      const d = Math.abs(cx - colCenters[i]);\n      if (d < cd) {\n        cd = d;\n        c = i;\n      }\n    }\n    let r = 0,\n      rd = Math.abs(cy - rowCenters[0]);\n    for (let j = 1; j < rowCenters.length; j++) {\n      const d = Math.abs(cy - rowCenters[j]);\n      if (d < rd) {\n        rd = d;\n        r = j;\n      }\n    }\n    const val = +t.text;\n    if (!isFinite(val)) continue;\n    // choose closest if multiple\n    if (!grid[r][c] || Math.hypot(cx - colCenters[c], cy - rowCenters[r]) < grid[r][c].dist) {\n      grid[r][c] = {\n        value: val,\n        dist: Math.hypot(cx - colCenters[c], cy - rowCenters[r])\n      };\n      cells[r][c] = t.bbox;\n    }\n  }\n  // map to numeric grid\n  const numeric = grid.map(row => row.map(cell => cell ? cell.value : null));\n  return {\n    numeric,\n    cells\n  };\n}\nfunction computeCellBoxes(rowCenters, colCenters) {\n  const rows = rowCenters.length,\n    cols = colCenters.length;\n  const xEdges = [];\n  for (let i = 0; i < cols; i++) {\n    if (i === 0) xEdges.push(colCenters[i] - (colCenters[i + 1] - colCenters[i]) / 2);else xEdges.push((colCenters[i - 1] + colCenters[i]) / 2);\n  }\n  xEdges.push(colCenters[cols - 1] + (colCenters[cols - 1] - colCenters[cols - 2]) / 2);\n  const yEdges = [];\n  for (let j = 0; j < rows; j++) {\n    if (j === 0) yEdges.push(rowCenters[j] - (rowCenters[j + 1] - rowCenters[j]) / 2);else yEdges.push((rowCenters[j - 1] + rowCenters[j]) / 2);\n  }\n  yEdges.push(rowCenters[rows - 1] + (rowCenters[rows - 1] - rowCenters[rows - 2]) / 2);\n  const boxes = Array.from({\n    length: rows\n  }, (_, r) => Array.from({\n    length: cols\n  }, (_, c) => ({\n    x0: Math.round(xEdges[c]),\n    y0: Math.round(yEdges[r]),\n    x1: Math.round(xEdges[c + 1]),\n    y1: Math.round(yEdges[r + 1])\n  })));\n  return boxes;\n}\nfunction linearFitIndices(values) {\n  // values: array of {idx, val}\n  const n = values.length;\n  if (n < 2) return null;\n  const xs = values.map(v => v.idx);\n  const ys = values.map(v => v.val);\n  const xMean = xs.reduce((a, b) => a + b, 0) / n;\n  const yMean = ys.reduce((a, b) => a + b, 0) / n;\n  let num = 0,\n    den = 0;\n  for (let i = 0; i < n; i++) {\n    num += (xs[i] - xMean) * (ys[i] - yMean);\n    den += (xs[i] - xMean) * (xs[i] - xMean);\n  }\n  if (den === 0) return null;\n  const b = num / den;\n  const a = yMean - b * xMean;\n  // compute residuals\n  const res = values.map((v, i) => v.val - (a + b * v.idx));\n  const mse = res.reduce((s, r) => s + r * r, 0) / n;\n  const rmse = Math.sqrt(mse);\n  return {\n    a,\n    b,\n    rmse\n  };\n}\nfunction tryFillByLinear(matrix, maxValue = 100) {\n  const rows = matrix.length,\n    cols = matrix[0].length;\n  const candidates = [];\n  for (const mode of ['row', 'col']) {\n    const vals = [];\n    for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {\n      const idx = mode === 'row' ? r * cols + c : c * rows + r;\n      const v = matrix[r][c];\n      if (v !== null && isFinite(v)) vals.push({\n        idx,\n        val: v\n      });\n    }\n    if (vals.length < 2) continue;\n    // sort by idx\n    vals.sort((a, b) => a.idx - b.idx);\n    // compute local steps for adjacent pairs\n    const steps = [];\n    for (let i = 0; i < vals.length - 1; i++) {\n      const di = vals[i + 1].idx - vals[i].idx;\n      if (di <= 0) continue;\n      const step = (vals[i + 1].val - vals[i].val) / di;\n      steps.push(step);\n    }\n    if (!steps.length) continue;\n    // median step\n    const sorted = steps.slice().sort((a, b) => a - b);\n    const medStep = sorted[Math.floor(sorted.length / 2)];\n    // measure variability\n    const diffs = steps.map(s => Math.abs(s - medStep));\n    const mad = diffs.sort((a, b) => a - b)[Math.floor(diffs.length / 2)];\n    // compute intercept a as median of val - medStep*idx\n    const as = vals.map(v => v.val - medStep * v.idx).sort((a, b) => a - b);\n    const a = as[Math.floor(as.length / 2)];\n    // compute residuals\n    const res = vals.map(v => v.val - (a + medStep * v.idx));\n    const mse = res.reduce((s, r) => s + r * r, 0) / res.length;\n    const rmse = Math.sqrt(mse);\n    // accept candidate only if medStep positive and reasonable\n    if (!(medStep > 0 && medStep < 100)) continue;\n    // require RMSE to be small relative to maxValue range\n    if (rmse > Math.max(2, 0.15 * maxValue)) continue;\n    candidates.push({\n      mode,\n      a,\n      b: medStep,\n      rmse,\n      known: vals.length\n    });\n  }\n  if (!candidates.length) return null;\n  // choose candidate with lowest rmse\n  candidates.sort((a, b) => a.rmse - b.rmse);\n  const best = candidates[0];\n  const {\n    a,\n    b\n  } = best;\n  const out = matrix.map(r => r.slice());\n  let filled = 0;\n  for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {\n    const idx = best.mode === 'row' ? r * cols + c : c * rows + r;\n    if (out[r][c] === null) {\n      const val = Math.round(a + b * idx);\n      if (isFinite(val) && val >= 1 && val <= maxValue) {\n        out[r][c] = val;\n        filled++;\n      }\n    }\n  }\n  return {\n    rows: out,\n    filled,\n    mode: best.mode,\n    fit: {\n      a,\n      b,\n      rmse: best.rmse\n    }\n  };\n}\nfunction tryFillByRowsCols(matrix, maxValue = 100) {\n  const rows = matrix.length,\n    cols = matrix[0].length;\n  const out = matrix.map(r => r.slice());\n  let filled = 0;\n  // per-row\n  for (let r = 0; r < rows; r++) {\n    const known = [];\n    for (let c = 0; c < cols; c++) if (out[r][c] !== null && isFinite(out[r][c])) known.push({\n      c,\n      v: out[r][c]\n    });\n    if (known.length < 3) continue;\n    // compute steps between adjacent knowns\n    const steps = [];\n    for (let i = 0; i < known.length - 1; i++) {\n      const di = known[i + 1].c - known[i].c;\n      if (di <= 0) continue;\n      steps.push((known[i + 1].v - known[i].v) / di);\n    }\n    if (!steps.length) continue;\n    const sorted = steps.slice().sort((a, b) => a - b);\n    const medStep = sorted[Math.floor(sorted.length / 2)];\n    // require medStep near integer and reasonable\n    const stepInt = Math.round(medStep);\n    if (!(medStep > 0 && medStep < maxValue && Math.abs(medStep - stepInt) <= Math.max(0.25, 0.1 * Math.abs(medStep)))) continue;\n    // compute a intercept estimate\n    const as = known.map(k => k.v - medStep * k.c).sort((a, b) => a - b);\n    const a = as[Math.floor(as.length / 2)];\n    // compute residuals\n    const res = known.map(k => k.v - (a + medStep * k.c));\n    const mse = res.reduce((s, r) => s + r * r, 0) / res.length;\n    const rmse = Math.sqrt(mse);\n    if (rmse > Math.max(0.5, 0.05 * maxValue)) continue;\n    // fill row conservatively (only if values unique and in range)\n    for (let c = 0; c < cols; c++) {\n      if (out[r][c] === null) {\n        const val = Math.round(a + medStep * c);\n        if (isFinite(val) && val >= 1 && val <= maxValue) {\n          // ensure not already present elsewhere\n          let present = false;\n          for (let rr = 0; rr < rows; rr++) for (let cc = 0; cc < cols; cc++) if (out[rr][cc] === val) present = true;\n          if (!present) {\n            out[r][c] = val;\n            filled++;\n          }\n        }\n      }\n    }\n  }\n  // per-column\n  for (let c = 0; c < cols; c++) {\n    const known = [];\n    for (let r = 0; r < rows; r++) if (out[r][c] !== null && isFinite(out[r][c])) known.push({\n      r,\n      v: out[r][c]\n    });\n    if (known.length < 3) continue;\n    const steps = [];\n    for (let i = 0; i < known.length - 1; i++) {\n      const di = known[i + 1].r - known[i].r;\n      if (di <= 0) continue;\n      steps.push((known[i + 1].v - known[i].v) / di);\n    }\n    if (!steps.length) continue;\n    const sorted = steps.slice().sort((a, b) => a - b);\n    const medStep = sorted[Math.floor(sorted.length / 2)];\n    const stepInt = Math.round(medStep);\n    if (!(medStep > 0 && medStep < maxValue && Math.abs(medStep - stepInt) <= Math.max(0.25, 0.1 * Math.abs(medStep)))) continue;\n    const as = known.map(k => k.v - medStep * k.r).sort((a, b) => a - b);\n    const a = as[Math.floor(as.length / 2)];\n    const res = known.map(k => k.v - (a + medStep * k.r));\n    const mse = res.reduce((s, r) => s + r * r, 0) / res.length;\n    const rmse = Math.sqrt(mse);\n    if (rmse > Math.max(0.5, 0.05 * maxValue)) continue;\n    // fill column conservatively\n    for (let r = 0; r < rows; r++) {\n      if (out[r][c] === null) {\n        const val = Math.round(a + medStep * r);\n        if (isFinite(val) && val >= 1 && val <= maxValue) {\n          let present = false;\n          for (let rr = 0; rr < rows; rr++) for (let cc = 0; cc < cols; cc++) if (out[rr][cc] === val) present = true;\n          if (!present) {\n            out[r][c] = val;\n            filled++;\n          }\n        }\n      }\n    }\n  }\n  return {\n    rows: out,\n    filled,\n    mode: 'rowscols'\n  };\n}\nexport function inferAndFill(tokens, opts = {}) {\n  // tokens: array with text and bbox\n  if (!tokens || tokens.length === 0) return null;\n  const maxValue = opts.maxValue || 100;\n  // Preprocess tokens: expand long digit runs into plausible small numbers\n  const expanded = [];\n  for (const t of tokens) {\n    const s = String(t.text).trim();\n    if (!/^\\d+$/.test(s)) continue;\n    if (s.length <= 3 && +s <= maxValue) {\n      expanded.push({\n        text: s,\n        bbox: t.bbox\n      });\n      continue;\n    }\n    // try split\n    const parts = splitDigitString(s, maxValue);\n    if (!parts) {\n      // if cannot split, still keep original but mark\n      expanded.push({\n        text: s,\n        bbox: t.bbox\n      });\n    } else {\n      // distribute bbox across parts proportionally to substring lengths\n      const totalLen = parts.reduce((a, b) => a + b.length, 0);\n      let x0 = t.bbox.x0;\n      for (const p of parts) {\n        const w = Math.max(1, Math.round(p.length / totalLen * (t.bbox.x1 - t.bbox.x0)));\n        expanded.push({\n          text: p,\n          bbox: {\n            x0,\n            y0: t.bbox.y0,\n            x1: x0 + w,\n            y1: t.bbox.y1\n          }\n        });\n        x0 += w;\n      }\n    }\n  }\n  const good = expanded.map(t => ({\n    text: String(t.text).trim(),\n    bbox: t.bbox\n  })).filter(t => /^\\d+$/.test(t.text));\n  if (!good.length) return null;\n  const {\n    rowCenters,\n    colCenters,\n    pts\n  } = computeGridCenters(good);\n  if (!rowCenters || !colCenters) return null;\n  const {\n    numeric,\n    cells\n  } = assignTokensToGrid(good, rowCenters, colCenters);\n  const boxes = computeCellBoxes(rowCenters, colCenters);\n  // filter numeric for fitting to those within [1,maxValue]\n  const filteredMatrix = numeric.map(r => r.map(v => v !== null && v >= 1 && v <= maxValue ? v : null));\n  const attempt = tryFillByLinear(filteredMatrix, opts.maxValue || maxValue);\n  if (attempt && attempt.filled > 0) {\n    // enforce bounds and integers\n    const rowsOut = attempt.rows.map(row => row.map(v => v === null ? null : Math.round(v)));\n    return {\n      rows: rowsOut,\n      cellBoxes: boxes,\n      orientation: attempt.mode,\n      filledCount: attempt.filled\n    };\n  }\n\n  // try row/column local fills\n  const local = tryFillByRowsCols(filteredMatrix, opts.maxValue || maxValue);\n  if (local && local.filled > 0) {\n    return {\n      rows: local.rows,\n      cellBoxes: boxes,\n      orientation: local.mode,\n      filledCount: local.filled\n    };\n  }\n\n  // fallback: return numeric with nulls\n  return {\n    rows: numeric,\n    cellBoxes: boxes,\n    orientation: 'none',\n    filledCount: 0\n  };\n}\n\n// helper: split a string of digits into numbers <= maxValue using DP\nfunction splitDigitString(s, maxValue) {\n  const n = s.length;\n  const dp = Array(n + 1).fill(null);\n  dp[0] = [];\n  for (let i = 0; i < n; i++) {\n    if (dp[i] === null) continue;\n    for (let l = 1; l <= 3 && i + l <= n; l++) {\n      const piece = s.substring(i, i + l);\n      // avoid leading zeros except '0' itself\n      if (piece.length > 1 && piece[0] === '0') continue;\n      const num = Number(piece);\n      if (num >= 1 && num <= maxValue) {\n        if (dp[i + l] === null || dp[i + l].length > dp[i].length + 1) dp[i + l] = dp[i].concat([piece]);\n      }\n    }\n  }\n  return dp[n] || null;\n}\nexport default {\n  inferAndFill\n};","map":{"version":3,"names":["cluster1d","values","gapFactor","length","s","sort","a","b","diffs","i","push","medianDiff","Math","floor","thresh","max","groups","cur","map","g","reduce","computeGridCenters","tokens","opts","pts","t","text","cx","bbox","x0","x1","cy","y0","y1","xs","p","ys","colCenters","rowCenters","makeEmptyGrid","rows","cols","Array","from","assignTokensToGrid","grid","cells","c","cd","abs","d","r","rd","j","val","isFinite","hypot","dist","value","numeric","row","cell","computeCellBoxes","xEdges","yEdges","boxes","_","round","linearFitIndices","n","v","idx","xMean","yMean","num","den","res","mse","rmse","sqrt","tryFillByLinear","matrix","maxValue","candidates","mode","vals","steps","di","step","sorted","slice","medStep","mad","as","known","best","out","filled","fit","tryFillByRowsCols","stepInt","k","present","rr","cc","inferAndFill","expanded","String","trim","test","parts","splitDigitString","totalLen","w","good","filter","filteredMatrix","attempt","rowsOut","cellBoxes","orientation","filledCount","local","dp","fill","l","piece","substring","Number","concat"],"sources":["C:/Users/Rande/bingocaller/src/utils/smartFill.js"],"sourcesContent":["/*\r\n  src/utils/smartFill.js\r\n  Infer a regular grid from OCR tokens and try to fill missing numbers by\r\n  detecting a linear pattern across the flattened grid (row-major or column-major).\r\n  Exports: inferAndFill(tokens, opts)\r\n\r\n  tokens: [{ text: '23', bbox: { x0,y0,x1,y1 } }, ... ] in image pixel coords\r\n  opts: { expectedRows?, expectedCols?, minAllowed?, maxAllowed? }\r\n  Returns: { rows: [[num|null,...],...], cellBoxes: [[{x0,y0,x1,y1},...],...], orientation, filledCount }\r\n*/\r\n\r\nfunction cluster1d(values, gapFactor = 1.5) {\r\n  if (!values.length) return []\r\n  const s = [...values].sort((a,b)=>a-b)\r\n  const diffs = []\r\n  for (let i=1;i<s.length;i++) diffs.push(s[i]-s[i-1])\r\n  const medianDiff = diffs.length ? diffs.sort((a,b)=>a-b)[Math.floor(diffs.length/2)] : 0\r\n  const thresh = Math.max(1, medianDiff * gapFactor)\r\n  const groups = []\r\n  let cur = [s[0]]\r\n  for (let i=1;i<s.length;i++){\r\n    if (s[i] - s[i-1] > thresh) { groups.push(cur); cur = [s[i]] } else cur.push(s[i])\r\n  }\r\n  if (cur.length) groups.push(cur)\r\n  return groups.map(g => g.reduce((a,b)=>a+b,0)/g.length)\r\n}\r\n\r\nfunction computeGridCenters(tokens, opts={}){\r\n  const pts = tokens.map(t=>({ text: t.text, cx: (t.bbox.x0 + t.bbox.x1)/2, cy: (t.bbox.y0 + t.bbox.y1)/2 }))\r\n  if (!pts.length) return null\r\n  const xs = pts.map(p=>p.cx)\r\n  const ys = pts.map(p=>p.cy)\r\n  const colCenters = cluster1d(xs, 1.2)\r\n  const rowCenters = cluster1d(ys, 1.2)\r\n  return { rowCenters, colCenters, pts }\r\n}\r\n\r\nfunction makeEmptyGrid(rows, cols){\r\n  return Array.from({length:rows}, ()=>Array.from({length:cols}, ()=>null))\r\n}\r\n\r\nfunction assignTokensToGrid(tokens, rowCenters, colCenters){\r\n  const rows = rowCenters.length, cols = colCenters.length\r\n  const grid = makeEmptyGrid(rows, cols)\r\n  const cells = Array.from({length:rows}, ()=>Array.from({length:cols}, ()=>null))\r\n  for (const t of tokens){\r\n    const cx = (t.bbox.x0 + t.bbox.x1)/2\r\n    const cy = (t.bbox.y0 + t.bbox.y1)/2\r\n    // find nearest col/row\r\n    let c=0, cd=Math.abs(cx - colCenters[0])\r\n    for (let i=1;i<colCenters.length;i++){ const d = Math.abs(cx - colCenters[i]); if (d < cd){ cd = d; c=i } }\r\n    let r=0, rd=Math.abs(cy - rowCenters[0])\r\n    for (let j=1;j<rowCenters.length;j++){ const d = Math.abs(cy - rowCenters[j]); if (d < rd){ rd = d; r=j } }\r\n    const val = +(t.text)\r\n    if (!isFinite(val)) continue\r\n    // choose closest if multiple\r\n    if (!grid[r][c] || (Math.hypot(cx - colCenters[c], cy - rowCenters[r]) < grid[r][c].dist)){\r\n      grid[r][c] = { value: val, dist: Math.hypot(cx - colCenters[c], cy - rowCenters[r]) }\r\n      cells[r][c] = t.bbox\r\n    }\r\n  }\r\n  // map to numeric grid\r\n  const numeric = grid.map(row => row.map(cell => cell ? cell.value : null))\r\n  return { numeric, cells }\r\n}\r\n\r\nfunction computeCellBoxes(rowCenters, colCenters){\r\n  const rows = rowCenters.length, cols = colCenters.length\r\n  const xEdges = []\r\n  for (let i=0;i<cols;i++){\r\n    if (i===0) xEdges.push(colCenters[i] - (colCenters[i+1]-colCenters[i])/2)\r\n    else xEdges.push((colCenters[i-1] + colCenters[i])/2)\r\n  }\r\n  xEdges.push(colCenters[cols-1] + (colCenters[cols-1]-colCenters[cols-2])/2)\r\n  const yEdges = []\r\n  for (let j=0;j<rows;j++){\r\n    if (j===0) yEdges.push(rowCenters[j] - (rowCenters[j+1]-rowCenters[j])/2)\r\n    else yEdges.push((rowCenters[j-1] + rowCenters[j])/2)\r\n  }\r\n  yEdges.push(rowCenters[rows-1] + (rowCenters[rows-1]-rowCenters[rows-2])/2)\r\n  const boxes = Array.from({length:rows}, (_,r)=>Array.from({length:cols}, (_,c)=>({ x0: Math.round(xEdges[c]), y0: Math.round(yEdges[r]), x1: Math.round(xEdges[c+1]), y1: Math.round(yEdges[r+1]) })))\r\n  return boxes\r\n}\r\n\r\nfunction linearFitIndices(values){\r\n  // values: array of {idx, val}\r\n  const n = values.length\r\n  if (n < 2) return null\r\n  const xs = values.map(v=>v.idx)\r\n  const ys = values.map(v=>v.val)\r\n  const xMean = xs.reduce((a,b)=>a+b,0)/n\r\n  const yMean = ys.reduce((a,b)=>a+b,0)/n\r\n  let num = 0, den = 0\r\n  for (let i=0;i<n;i++){ num += (xs[i]-xMean)*(ys[i]-yMean); den += (xs[i]-xMean)*(xs[i]-xMean) }\r\n  if (den === 0) return null\r\n  const b = num/den\r\n  const a = yMean - b * xMean\r\n  // compute residuals\r\n  const res = values.map((v,i)=> v.val - (a + b * v.idx))\r\n  const mse = res.reduce((s,r)=>s + r*r, 0) / n\r\n  const rmse = Math.sqrt(mse)\r\n  return { a, b, rmse }\r\n}\r\n\r\nfunction tryFillByLinear(matrix, maxValue = 100){\r\n  const rows = matrix.length, cols = matrix[0].length\r\n  const candidates = []\r\n  for (const mode of ['row','col']){\r\n    const vals = []\r\n    for (let r=0;r<rows;r++) for (let c=0;c<cols;c++){\r\n      const idx = mode === 'row' ? r*cols + c : c*rows + r\r\n      const v = matrix[r][c]\r\n      if (v !== null && isFinite(v)) vals.push({ idx, val: v })\r\n    }\r\n    if (vals.length < 2) continue\r\n    // sort by idx\r\n    vals.sort((a,b)=>a.idx-b.idx)\r\n    // compute local steps for adjacent pairs\r\n    const steps = []\r\n    for (let i=0;i<vals.length-1;i++){\r\n      const di = vals[i+1].idx - vals[i].idx\r\n      if (di <= 0) continue\r\n      const step = (vals[i+1].val - vals[i].val) / di\r\n      steps.push(step)\r\n    }\r\n    if (!steps.length) continue\r\n    // median step\r\n    const sorted = steps.slice().sort((a,b)=>a-b)\r\n    const medStep = sorted[Math.floor(sorted.length/2)]\r\n    // measure variability\r\n    const diffs = steps.map(s => Math.abs(s - medStep))\r\n    const mad = diffs.sort((a,b)=>a-b)[Math.floor(diffs.length/2)]\r\n    // compute intercept a as median of val - medStep*idx\r\n    const as = vals.map(v => v.val - medStep * v.idx).sort((a,b)=>a-b)\r\n    const a = as[Math.floor(as.length/2)]\r\n    // compute residuals\r\n    const res = vals.map(v => v.val - (a + medStep * v.idx))\r\n    const mse = res.reduce((s,r)=>s + r*r, 0) / res.length\r\n    const rmse = Math.sqrt(mse)\r\n    // accept candidate only if medStep positive and reasonable\r\n    if (!(medStep > 0 && medStep < 100)) continue\r\n    // require RMSE to be small relative to maxValue range\r\n    if (rmse > Math.max(2, 0.15 * (maxValue))) continue\r\n    candidates.push({ mode, a, b: medStep, rmse, known: vals.length })\r\n  }\r\n  if (!candidates.length) return null\r\n  // choose candidate with lowest rmse\r\n  candidates.sort((a,b)=>a.rmse - b.rmse)\r\n  const best = candidates[0]\r\n  const { a, b } = best\r\n  const out = matrix.map(r=>r.slice())\r\n  let filled = 0\r\n  for (let r=0;r<rows;r++) for (let c=0;c<cols;c++){\r\n    const idx = best.mode === 'row' ? r*cols + c : c*rows + r\r\n    if (out[r][c] === null) {\r\n      const val = Math.round(a + b * idx)\r\n      if (isFinite(val) && val >= 1 && val <= maxValue) { out[r][c] = val; filled++ }\r\n    }\r\n  }\r\n  return { rows: out, filled, mode: best.mode, fit: { a, b, rmse: best.rmse } }\r\n}\r\n\r\nfunction tryFillByRowsCols(matrix, maxValue=100){\r\n  const rows = matrix.length, cols = matrix[0].length\r\n  const out = matrix.map(r=>r.slice())\r\n  let filled = 0\r\n  // per-row\r\n  for (let r=0;r<rows;r++){\r\n    const known = []\r\n    for (let c=0;c<cols;c++) if (out[r][c] !== null && isFinite(out[r][c])) known.push({c, v: out[r][c]})\r\n    if (known.length < 3) continue\r\n    // compute steps between adjacent knowns\r\n    const steps = []\r\n    for (let i=0;i<known.length-1;i++){\r\n      const di = known[i+1].c - known[i].c\r\n      if (di<=0) continue\r\n      steps.push((known[i+1].v - known[i].v)/di)\r\n    }\r\n    if (!steps.length) continue\r\n    const sorted = steps.slice().sort((a,b)=>a-b)\r\n    const medStep = sorted[Math.floor(sorted.length/2)]\r\n    // require medStep near integer and reasonable\r\n    const stepInt = Math.round(medStep)\r\n    if (!(medStep > 0 && medStep < maxValue && Math.abs(medStep - stepInt) <= Math.max(0.25, 0.1 * Math.abs(medStep)))) continue\r\n    // compute a intercept estimate\r\n    const as = known.map(k => k.v - medStep * k.c).sort((a,b)=>a-b)\r\n    const a = as[Math.floor(as.length/2)]\r\n    // compute residuals\r\n    const res = known.map(k => k.v - (a + medStep * k.c))\r\n    const mse = res.reduce((s,r)=>s + r*r,0)/res.length\r\n    const rmse = Math.sqrt(mse)\r\n    if (rmse > Math.max(0.5, 0.05 * maxValue)) continue\r\n    // fill row conservatively (only if values unique and in range)\r\n    for (let c=0;c<cols;c++){\r\n      if (out[r][c] === null){\r\n        const val = Math.round(a + medStep * c)\r\n        if (isFinite(val) && val>=1 && val<=maxValue){\r\n          // ensure not already present elsewhere\r\n          let present = false\r\n          for (let rr=0;rr<rows;rr++) for (let cc=0;cc<cols;cc++) if (out[rr][cc] === val) present = true\r\n          if (!present) { out[r][c]=val; filled++ }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // per-column\r\n  for (let c=0;c<cols;c++){\r\n    const known = []\r\n    for (let r=0;r<rows;r++) if (out[r][c] !== null && isFinite(out[r][c])) known.push({r, v: out[r][c]})\r\n    if (known.length < 3) continue\r\n    const steps = []\r\n    for (let i=0;i<known.length-1;i++){\r\n      const di = known[i+1].r - known[i].r\r\n      if (di<=0) continue\r\n      steps.push((known[i+1].v - known[i].v)/di)\r\n    }\r\n    if (!steps.length) continue\r\n    const sorted = steps.slice().sort((a,b)=>a-b)\r\n    const medStep = sorted[Math.floor(sorted.length/2)]\r\n    const stepInt = Math.round(medStep)\r\n    if (!(medStep > 0 && medStep < maxValue && Math.abs(medStep - stepInt) <= Math.max(0.25, 0.1 * Math.abs(medStep)))) continue\r\n    const as = known.map(k=>k.v - medStep * k.r).sort((a,b)=>a-b)\r\n    const a = as[Math.floor(as.length/2)]\r\n    const res = known.map(k => k.v - (a + medStep * k.r))\r\n    const mse = res.reduce((s,r)=>s + r*r,0)/res.length\r\n    const rmse = Math.sqrt(mse)\r\n    if (rmse > Math.max(0.5, 0.05 * maxValue)) continue\r\n    // fill column conservatively\r\n    for (let r=0;r<rows;r++){\r\n      if (out[r][c] === null){\r\n        const val = Math.round(a + medStep * r)\r\n        if (isFinite(val) && val>=1 && val<=maxValue){\r\n          let present = false\r\n          for (let rr=0;rr<rows;rr++) for (let cc=0;cc<cols;cc++) if (out[rr][cc] === val) present = true\r\n          if (!present) { out[r][c]=val; filled++ }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return { rows: out, filled, mode: 'rowscols' }\r\n}\r\n\r\nexport function inferAndFill(tokens, opts = {}){\r\n  // tokens: array with text and bbox\r\n  if (!tokens || tokens.length === 0) return null\r\n  const maxValue = opts.maxValue || 100\r\n  // Preprocess tokens: expand long digit runs into plausible small numbers\r\n  const expanded = []\r\n  for (const t of tokens) {\r\n    const s = String(t.text).trim()\r\n    if (!/^\\d+$/.test(s)) continue\r\n    if (s.length <= 3 && +(s) <= maxValue) {\r\n      expanded.push({ text: s, bbox: t.bbox })\r\n      continue\r\n    }\r\n    // try split\r\n    const parts = splitDigitString(s, maxValue)\r\n    if (!parts) {\r\n      // if cannot split, still keep original but mark\r\n      expanded.push({ text: s, bbox: t.bbox })\r\n    } else {\r\n      // distribute bbox across parts proportionally to substring lengths\r\n      const totalLen = parts.reduce((a,b)=>a+b.length,0)\r\n      let x0 = t.bbox.x0\r\n      for (const p of parts) {\r\n        const w = Math.max(1, Math.round((p.length / totalLen) * (t.bbox.x1 - t.bbox.x0)))\r\n        expanded.push({ text: p, bbox: { x0, y0: t.bbox.y0, x1: x0 + w, y1: t.bbox.y1 } })\r\n        x0 += w\r\n      }\r\n    }\r\n  }\r\n\r\n  const good = expanded.map(t => ({ text: String(t.text).trim(), bbox: t.bbox })).filter(t => /^\\d+$/.test(t.text))\r\n  if (!good.length) return null\r\n\r\n  const { rowCenters, colCenters, pts } = computeGridCenters(good)\r\n  if (!rowCenters || !colCenters) return null\r\n  const { numeric, cells } = assignTokensToGrid(good, rowCenters, colCenters)\r\n  const boxes = computeCellBoxes(rowCenters, colCenters)\r\n  // filter numeric for fitting to those within [1,maxValue]\r\n  const filteredMatrix = numeric.map(r => r.map(v => (v !== null && v >= 1 && v <= maxValue) ? v : null))\r\n  const attempt = tryFillByLinear(filteredMatrix, opts.maxValue || maxValue)\r\n  if (attempt && attempt.filled > 0) {\r\n    // enforce bounds and integers\r\n    const rowsOut = attempt.rows.map(row => row.map(v => (v === null ? null : Math.round(v))))\r\n    return { rows: rowsOut, cellBoxes: boxes, orientation: attempt.mode, filledCount: attempt.filled }\r\n  }\r\n\r\n  // try row/column local fills\r\n  const local = tryFillByRowsCols(filteredMatrix, opts.maxValue || maxValue)\r\n  if (local && local.filled > 0) {\r\n    return { rows: local.rows, cellBoxes: boxes, orientation: local.mode, filledCount: local.filled }\r\n  }\r\n\r\n  // fallback: return numeric with nulls\r\n  return { rows: numeric, cellBoxes: boxes, orientation: 'none', filledCount: 0 }\r\n}\r\n\r\n// helper: split a string of digits into numbers <= maxValue using DP\r\nfunction splitDigitString(s, maxValue){\r\n  const n = s.length\r\n  const dp = Array(n+1).fill(null)\r\n  dp[0] = []\r\n  for (let i=0;i<n;i++){\r\n    if (dp[i] === null) continue\r\n    for (let l=1;l<=3 && i+l<=n;l++){\r\n      const piece = s.substring(i, i+l)\r\n      // avoid leading zeros except '0' itself\r\n      if (piece.length > 1 && piece[0] === '0') continue\r\n      const num = Number(piece)\r\n      if (num >= 1 && num <= maxValue) {\r\n        if (dp[i+l] === null || dp[i+l].length > dp[i].length + 1) dp[i+l] = dp[i].concat([piece])\r\n      }\r\n    }\r\n  }\r\n  return dp[n] || null\r\n}\r\n\r\nexport default { inferAndFill }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}