{"ast":null,"code":"// src/utils/imageRows.js\n// Simple image-based row detection using horizontal projection of grayscale pixels.\n// Exports: detectRowsFromImage(imgElement, opts) -> { rows: number, rowCenters: [y0, y1..], bands: [{y0,y1,center}] }\n\nexport async function detectRowsFromImage(img, opts = {}) {\n  // opts: { downscaleWidth: number, minRowHeight: number, smoothRadius }\n  const downW = opts.downscaleWidth || 800;\n  const minRowH = opts.minRowHeight || 10;\n  const smoothRadius = opts.smoothRadius || 6;\n\n  // draw image to canvas scaled to downW keeping aspect\n  const canvas = document.createElement('canvas');\n  const ratio = Math.min(1, downW / img.naturalWidth);\n  const w = Math.max(1, Math.round(img.naturalWidth * ratio));\n  const h = Math.max(1, Math.round(img.naturalHeight * ratio));\n  canvas.width = w;\n  canvas.height = h;\n  const ctx = canvas.getContext('2d');\n  ctx.drawImage(img, 0, 0, w, h);\n  const data = ctx.getImageData(0, 0, w, h).data;\n\n  // compute horizontal projection: darkness per row\n  const proj = new Float32Array(h);\n  for (let y = 0; y < h; y++) {\n    let s = 0;\n    for (let x = 0; x < w; x++) {\n      const i = (y * w + x) * 4;\n      const r = data[i],\n        g = data[i + 1],\n        b = data[i + 2];\n      // luminance\n      const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n      // dark contribution\n      s += 255 - lum;\n    }\n    proj[y] = s / w;\n  }\n\n  // smooth projection with moving average\n  const smooth = new Float32Array(h);\n  const rad = Math.max(1, Math.round(smoothRadius * ratio));\n  for (let y = 0; y < h; y++) {\n    let s = 0,\n      c = 0;\n    const lo = Math.max(0, y - rad),\n      hi = Math.min(h - 1, y + rad);\n    for (let k = lo; k <= hi; k++) {\n      s += proj[k];\n      c++;\n    }\n    smooth[y] = s / c;\n  }\n\n  // find peaks (rows) by local maxima and spacing\n  const peaks = [];\n  for (let y = 1; y < h - 1; y++) {\n    if (smooth[y] > smooth[y - 1] && smooth[y] >= smooth[y + 1] && smooth[y] > 3) peaks.push({\n      y,\n      score: smooth[y]\n    });\n  }\n  if (!peaks.length) return {\n    rows: 0,\n    rowCenters: [],\n    bands: []\n  };\n\n  // cluster peaks by distance to estimate rows\n  // compute median gap\n  const ys = peaks.map(p => p.y).sort((a, b) => a - b);\n  const gaps = [];\n  for (let i = 1; i < ys.length; i++) gaps.push(ys[i] - ys[i - 1]);\n  const medianGap = gaps.length ? gaps.sort((a, b) => a - b)[Math.floor(gaps.length / 2)] : Math.max(10, Math.round(h / 10));\n  // group peaks into row centers by merging peaks closer than medianGap/2\n  const groups = [];\n  let cur = [ys[0]];\n  for (let i = 1; i < ys.length; i++) {\n    if (ys[i] - ys[i - 1] <= Math.max(4, medianGap / 2)) cur.push(ys[i]);else {\n      groups.push(cur);\n      cur = [ys[i]];\n    }\n  }\n  if (cur.length) groups.push(cur);\n  const centers = groups.map(g => g.reduce((a, b) => a + b, 0) / g.length);\n\n  // convert centers back to original image coordinates (un-scale)\n  const rowCenters = centers.map(c => Math.round(c / ratio));\n\n  // build bands (min/max) using half gap between centers\n  const bands = [];\n  for (let i = 0; i < rowCenters.length; i++) {\n    const c = rowCenters[i];\n    const prev = rowCenters[i - 1] || null;\n    const next = rowCenters[i + 1] || null;\n    const half = Math.round(((next ? next : c + (next || 0)) - (prev ? prev : c - (prev || 0))) / 2) || Math.round(img.naturalHeight / (rowCenters.length || 1) / 4);\n    const y0 = Math.max(0, c - half);\n    const y1 = Math.min(img.naturalHeight, c + half);\n    if (y1 - y0 >= minRowH) bands.push({\n      y0,\n      y1,\n      center: c\n    });\n  }\n  return {\n    rows: bands.length,\n    rowCenters: centers.map(c => Math.round(c / ratio)),\n    bands\n  };\n}\nexport default {\n  detectRowsFromImage\n};","map":{"version":3,"names":["detectRowsFromImage","img","opts","downW","downscaleWidth","minRowH","minRowHeight","smoothRadius","canvas","document","createElement","ratio","Math","min","naturalWidth","w","max","round","h","naturalHeight","width","height","ctx","getContext","drawImage","data","getImageData","proj","Float32Array","y","s","x","i","r","g","b","lum","smooth","rad","c","lo","hi","k","peaks","push","score","length","rows","rowCenters","bands","ys","map","p","sort","a","gaps","medianGap","floor","groups","cur","centers","reduce","prev","next","half","y0","y1","center"],"sources":["C:/Users/Rande/bingocaller/src/utils/imageRows.js"],"sourcesContent":["// src/utils/imageRows.js\r\n// Simple image-based row detection using horizontal projection of grayscale pixels.\r\n// Exports: detectRowsFromImage(imgElement, opts) -> { rows: number, rowCenters: [y0, y1..], bands: [{y0,y1,center}] }\r\n\r\nexport async function detectRowsFromImage(img, opts = {}){\r\n  // opts: { downscaleWidth: number, minRowHeight: number, smoothRadius }\r\n  const downW = opts.downscaleWidth || 800\r\n  const minRowH = opts.minRowHeight || 10\r\n  const smoothRadius = opts.smoothRadius || 6\r\n\r\n  // draw image to canvas scaled to downW keeping aspect\r\n  const canvas = document.createElement('canvas')\r\n  const ratio = Math.min(1, downW / img.naturalWidth)\r\n  const w = Math.max(1, Math.round(img.naturalWidth * ratio))\r\n  const h = Math.max(1, Math.round(img.naturalHeight * ratio))\r\n  canvas.width = w\r\n  canvas.height = h\r\n  const ctx = canvas.getContext('2d')\r\n  ctx.drawImage(img, 0, 0, w, h)\r\n  const data = ctx.getImageData(0,0,w,h).data\r\n\r\n  // compute horizontal projection: darkness per row\r\n  const proj = new Float32Array(h)\r\n  for (let y=0;y<h;y++){\r\n    let s = 0\r\n    for (let x=0;x<w;x++){\r\n      const i = (y*w + x) * 4\r\n      const r = data[i], g = data[i+1], b = data[i+2]\r\n      // luminance\r\n      const lum = 0.2126*r + 0.7152*g + 0.0722*b\r\n      // dark contribution\r\n      s += (255 - lum)\r\n    }\r\n    proj[y] = s / w\r\n  }\r\n\r\n  // smooth projection with moving average\r\n  const smooth = new Float32Array(h)\r\n  const rad = Math.max(1, Math.round(smoothRadius * ratio))\r\n  for (let y=0;y<h;y++){\r\n    let s=0, c=0\r\n    const lo = Math.max(0, y-rad), hi = Math.min(h-1, y+rad)\r\n    for (let k=lo;k<=hi;k++){ s+=proj[k]; c++ }\r\n    smooth[y] = s / c\r\n  }\r\n\r\n  // find peaks (rows) by local maxima and spacing\r\n  const peaks = []\r\n  for (let y=1;y<h-1;y++){\r\n    if (smooth[y] > smooth[y-1] && smooth[y] >= smooth[y+1] && smooth[y] > 3) peaks.push({y, score: smooth[y]})\r\n  }\r\n  if (!peaks.length) return { rows: 0, rowCenters: [], bands: [] }\r\n\r\n  // cluster peaks by distance to estimate rows\r\n  // compute median gap\r\n  const ys = peaks.map(p=>p.y).sort((a,b)=>a-b)\r\n  const gaps = []\r\n  for (let i=1;i<ys.length;i++) gaps.push(ys[i]-ys[i-1])\r\n  const medianGap = gaps.length ? gaps.sort((a,b)=>a-b)[Math.floor(gaps.length/2)] : Math.max(10, Math.round(h/10))\r\n  // group peaks into row centers by merging peaks closer than medianGap/2\r\n  const groups = []\r\n  let cur = [ys[0]]\r\n  for (let i=1;i<ys.length;i++){\r\n    if (ys[i]-ys[i-1] <= Math.max(4, medianGap/2)) cur.push(ys[i])\r\n    else { groups.push(cur); cur=[ys[i]] }\r\n  }\r\n  if (cur.length) groups.push(cur)\r\n  const centers = groups.map(g => g.reduce((a,b)=>a+b,0)/g.length)\r\n\r\n  // convert centers back to original image coordinates (un-scale)\r\n  const rowCenters = centers.map(c => Math.round(c / ratio))\r\n\r\n  // build bands (min/max) using half gap between centers\r\n  const bands = []\r\n  for (let i=0;i<rowCenters.length;i++){\r\n    const c = rowCenters[i]\r\n    const prev = rowCenters[i-1] || null\r\n    const next = rowCenters[i+1] || null\r\n    const half = Math.round(((next? next : c + (next||0)) - (prev? prev : c - (prev||0))) / 2) || Math.round((img.naturalHeight / (rowCenters.length||1)) / 4)\r\n    const y0 = Math.max(0, c - half)\r\n    const y1 = Math.min(img.naturalHeight, c + half)\r\n    if (y1 - y0 >= minRowH) bands.push({ y0, y1, center: c })\r\n  }\r\n\r\n  return { rows: bands.length, rowCenters: centers.map(c => Math.round(c/ratio)), bands }\r\n}\r\n\r\nexport default { detectRowsFromImage }"],"mappings":"AAAA;AACA;AACA;;AAEA,OAAO,eAAeA,mBAAmBA,CAACC,GAAG,EAAEC,IAAI,GAAG,CAAC,CAAC,EAAC;EACvD;EACA,MAAMC,KAAK,GAAGD,IAAI,CAACE,cAAc,IAAI,GAAG;EACxC,MAAMC,OAAO,GAAGH,IAAI,CAACI,YAAY,IAAI,EAAE;EACvC,MAAMC,YAAY,GAAGL,IAAI,CAACK,YAAY,IAAI,CAAC;;EAE3C;EACA,MAAMC,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;EAC/C,MAAMC,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEV,KAAK,GAAGF,GAAG,CAACa,YAAY,CAAC;EACnD,MAAMC,CAAC,GAAGH,IAAI,CAACI,GAAG,CAAC,CAAC,EAAEJ,IAAI,CAACK,KAAK,CAAChB,GAAG,CAACa,YAAY,GAAGH,KAAK,CAAC,CAAC;EAC3D,MAAMO,CAAC,GAAGN,IAAI,CAACI,GAAG,CAAC,CAAC,EAAEJ,IAAI,CAACK,KAAK,CAAChB,GAAG,CAACkB,aAAa,GAAGR,KAAK,CAAC,CAAC;EAC5DH,MAAM,CAACY,KAAK,GAAGL,CAAC;EAChBP,MAAM,CAACa,MAAM,GAAGH,CAAC;EACjB,MAAMI,GAAG,GAAGd,MAAM,CAACe,UAAU,CAAC,IAAI,CAAC;EACnCD,GAAG,CAACE,SAAS,CAACvB,GAAG,EAAE,CAAC,EAAE,CAAC,EAAEc,CAAC,EAAEG,CAAC,CAAC;EAC9B,MAAMO,IAAI,GAAGH,GAAG,CAACI,YAAY,CAAC,CAAC,EAAC,CAAC,EAACX,CAAC,EAACG,CAAC,CAAC,CAACO,IAAI;;EAE3C;EACA,MAAME,IAAI,GAAG,IAAIC,YAAY,CAACV,CAAC,CAAC;EAChC,KAAK,IAAIW,CAAC,GAAC,CAAC,EAACA,CAAC,GAACX,CAAC,EAACW,CAAC,EAAE,EAAC;IACnB,IAAIC,CAAC,GAAG,CAAC;IACT,KAAK,IAAIC,CAAC,GAAC,CAAC,EAACA,CAAC,GAAChB,CAAC,EAACgB,CAAC,EAAE,EAAC;MACnB,MAAMC,CAAC,GAAG,CAACH,CAAC,GAACd,CAAC,GAAGgB,CAAC,IAAI,CAAC;MACvB,MAAME,CAAC,GAAGR,IAAI,CAACO,CAAC,CAAC;QAAEE,CAAC,GAAGT,IAAI,CAACO,CAAC,GAAC,CAAC,CAAC;QAAEG,CAAC,GAAGV,IAAI,CAACO,CAAC,GAAC,CAAC,CAAC;MAC/C;MACA,MAAMI,GAAG,GAAG,MAAM,GAACH,CAAC,GAAG,MAAM,GAACC,CAAC,GAAG,MAAM,GAACC,CAAC;MAC1C;MACAL,CAAC,IAAK,GAAG,GAAGM,GAAI;IAClB;IACAT,IAAI,CAACE,CAAC,CAAC,GAAGC,CAAC,GAAGf,CAAC;EACjB;;EAEA;EACA,MAAMsB,MAAM,GAAG,IAAIT,YAAY,CAACV,CAAC,CAAC;EAClC,MAAMoB,GAAG,GAAG1B,IAAI,CAACI,GAAG,CAAC,CAAC,EAAEJ,IAAI,CAACK,KAAK,CAACV,YAAY,GAAGI,KAAK,CAAC,CAAC;EACzD,KAAK,IAAIkB,CAAC,GAAC,CAAC,EAACA,CAAC,GAACX,CAAC,EAACW,CAAC,EAAE,EAAC;IACnB,IAAIC,CAAC,GAAC,CAAC;MAAES,CAAC,GAAC,CAAC;IACZ,MAAMC,EAAE,GAAG5B,IAAI,CAACI,GAAG,CAAC,CAAC,EAAEa,CAAC,GAACS,GAAG,CAAC;MAAEG,EAAE,GAAG7B,IAAI,CAACC,GAAG,CAACK,CAAC,GAAC,CAAC,EAAEW,CAAC,GAACS,GAAG,CAAC;IACxD,KAAK,IAAII,CAAC,GAACF,EAAE,EAACE,CAAC,IAAED,EAAE,EAACC,CAAC,EAAE,EAAC;MAAEZ,CAAC,IAAEH,IAAI,CAACe,CAAC,CAAC;MAAEH,CAAC,EAAE;IAAC;IAC1CF,MAAM,CAACR,CAAC,CAAC,GAAGC,CAAC,GAAGS,CAAC;EACnB;;EAEA;EACA,MAAMI,KAAK,GAAG,EAAE;EAChB,KAAK,IAAId,CAAC,GAAC,CAAC,EAACA,CAAC,GAACX,CAAC,GAAC,CAAC,EAACW,CAAC,EAAE,EAAC;IACrB,IAAIQ,MAAM,CAACR,CAAC,CAAC,GAAGQ,MAAM,CAACR,CAAC,GAAC,CAAC,CAAC,IAAIQ,MAAM,CAACR,CAAC,CAAC,IAAIQ,MAAM,CAACR,CAAC,GAAC,CAAC,CAAC,IAAIQ,MAAM,CAACR,CAAC,CAAC,GAAG,CAAC,EAAEc,KAAK,CAACC,IAAI,CAAC;MAACf,CAAC;MAAEgB,KAAK,EAAER,MAAM,CAACR,CAAC;IAAC,CAAC,CAAC;EAC7G;EACA,IAAI,CAACc,KAAK,CAACG,MAAM,EAAE,OAAO;IAAEC,IAAI,EAAE,CAAC;IAAEC,UAAU,EAAE,EAAE;IAAEC,KAAK,EAAE;EAAG,CAAC;;EAEhE;EACA;EACA,MAAMC,EAAE,GAAGP,KAAK,CAACQ,GAAG,CAACC,CAAC,IAAEA,CAAC,CAACvB,CAAC,CAAC,CAACwB,IAAI,CAAC,CAACC,CAAC,EAACnB,CAAC,KAAGmB,CAAC,GAACnB,CAAC,CAAC;EAC7C,MAAMoB,IAAI,GAAG,EAAE;EACf,KAAK,IAAIvB,CAAC,GAAC,CAAC,EAACA,CAAC,GAACkB,EAAE,CAACJ,MAAM,EAACd,CAAC,EAAE,EAAEuB,IAAI,CAACX,IAAI,CAACM,EAAE,CAAClB,CAAC,CAAC,GAACkB,EAAE,CAAClB,CAAC,GAAC,CAAC,CAAC,CAAC;EACtD,MAAMwB,SAAS,GAAGD,IAAI,CAACT,MAAM,GAAGS,IAAI,CAACF,IAAI,CAAC,CAACC,CAAC,EAACnB,CAAC,KAAGmB,CAAC,GAACnB,CAAC,CAAC,CAACvB,IAAI,CAAC6C,KAAK,CAACF,IAAI,CAACT,MAAM,GAAC,CAAC,CAAC,CAAC,GAAGlC,IAAI,CAACI,GAAG,CAAC,EAAE,EAAEJ,IAAI,CAACK,KAAK,CAACC,CAAC,GAAC,EAAE,CAAC,CAAC;EACjH;EACA,MAAMwC,MAAM,GAAG,EAAE;EACjB,IAAIC,GAAG,GAAG,CAACT,EAAE,CAAC,CAAC,CAAC,CAAC;EACjB,KAAK,IAAIlB,CAAC,GAAC,CAAC,EAACA,CAAC,GAACkB,EAAE,CAACJ,MAAM,EAACd,CAAC,EAAE,EAAC;IAC3B,IAAIkB,EAAE,CAAClB,CAAC,CAAC,GAACkB,EAAE,CAAClB,CAAC,GAAC,CAAC,CAAC,IAAIpB,IAAI,CAACI,GAAG,CAAC,CAAC,EAAEwC,SAAS,GAAC,CAAC,CAAC,EAAEG,GAAG,CAACf,IAAI,CAACM,EAAE,CAAClB,CAAC,CAAC,CAAC,MACzD;MAAE0B,MAAM,CAACd,IAAI,CAACe,GAAG,CAAC;MAAEA,GAAG,GAAC,CAACT,EAAE,CAAClB,CAAC,CAAC,CAAC;IAAC;EACvC;EACA,IAAI2B,GAAG,CAACb,MAAM,EAAEY,MAAM,CAACd,IAAI,CAACe,GAAG,CAAC;EAChC,MAAMC,OAAO,GAAGF,MAAM,CAACP,GAAG,CAACjB,CAAC,IAAIA,CAAC,CAAC2B,MAAM,CAAC,CAACP,CAAC,EAACnB,CAAC,KAAGmB,CAAC,GAACnB,CAAC,EAAC,CAAC,CAAC,GAACD,CAAC,CAACY,MAAM,CAAC;;EAEhE;EACA,MAAME,UAAU,GAAGY,OAAO,CAACT,GAAG,CAACZ,CAAC,IAAI3B,IAAI,CAACK,KAAK,CAACsB,CAAC,GAAG5B,KAAK,CAAC,CAAC;;EAE1D;EACA,MAAMsC,KAAK,GAAG,EAAE;EAChB,KAAK,IAAIjB,CAAC,GAAC,CAAC,EAACA,CAAC,GAACgB,UAAU,CAACF,MAAM,EAACd,CAAC,EAAE,EAAC;IACnC,MAAMO,CAAC,GAAGS,UAAU,CAAChB,CAAC,CAAC;IACvB,MAAM8B,IAAI,GAAGd,UAAU,CAAChB,CAAC,GAAC,CAAC,CAAC,IAAI,IAAI;IACpC,MAAM+B,IAAI,GAAGf,UAAU,CAAChB,CAAC,GAAC,CAAC,CAAC,IAAI,IAAI;IACpC,MAAMgC,IAAI,GAAGpD,IAAI,CAACK,KAAK,CAAC,CAAC,CAAC8C,IAAI,GAAEA,IAAI,GAAGxB,CAAC,IAAIwB,IAAI,IAAE,CAAC,CAAC,KAAKD,IAAI,GAAEA,IAAI,GAAGvB,CAAC,IAAIuB,IAAI,IAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAIlD,IAAI,CAACK,KAAK,CAAEhB,GAAG,CAACkB,aAAa,IAAI6B,UAAU,CAACF,MAAM,IAAE,CAAC,CAAC,GAAI,CAAC,CAAC;IAC1J,MAAMmB,EAAE,GAAGrD,IAAI,CAACI,GAAG,CAAC,CAAC,EAAEuB,CAAC,GAAGyB,IAAI,CAAC;IAChC,MAAME,EAAE,GAAGtD,IAAI,CAACC,GAAG,CAACZ,GAAG,CAACkB,aAAa,EAAEoB,CAAC,GAAGyB,IAAI,CAAC;IAChD,IAAIE,EAAE,GAAGD,EAAE,IAAI5D,OAAO,EAAE4C,KAAK,CAACL,IAAI,CAAC;MAAEqB,EAAE;MAAEC,EAAE;MAAEC,MAAM,EAAE5B;IAAE,CAAC,CAAC;EAC3D;EAEA,OAAO;IAAEQ,IAAI,EAAEE,KAAK,CAACH,MAAM;IAAEE,UAAU,EAAEY,OAAO,CAACT,GAAG,CAACZ,CAAC,IAAI3B,IAAI,CAACK,KAAK,CAACsB,CAAC,GAAC5B,KAAK,CAAC,CAAC;IAAEsC;EAAM,CAAC;AACzF;AAEA,eAAe;EAAEjD;AAAoB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}