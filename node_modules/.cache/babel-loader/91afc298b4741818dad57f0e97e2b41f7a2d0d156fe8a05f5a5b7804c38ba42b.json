{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Rande\\\\bingocaller\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\n/*\n  src/App.js\n  Main application container. Coordinates OCR upload, card state,\n  ball picker, dab logic, auto/manual modes, and win detection.\n*/\nimport React, { useEffect, useState, useCallback } from 'react';\nimport ImageUploader from './components/ImageUploader';\nimport CardView from './components/CardView';\nimport BallPicker from './components/BallPicker';\nimport PlayerList from './components/PlayerList';\nimport WinModal from './components/WinModal';\nimport { useLocalStorage } from './hooks/useLocalStorage';\nimport { fireConfetti } from './utils/confetti';\n\n// Keys for localStorage\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst LS_KEYS = {\n  CARD: 'bingo_card',\n  PLAYERS: 'bingo_players',\n  DABBED: 'bingo_dabbed',\n  CALLED: 'bingo_called',\n  SETTINGS: 'bingo_settings',\n  BOXES: 'bingo_boxes',\n  IMAGE_URL: 'bingo_image_url'\n};\nfunction defaultEmptyCard(rows = 5, cols = 5) {\n  // generate an empty card of placeholders (null means empty cell)\n  return Array.from({\n    length: rows\n  }, () => Array.from({\n    length: cols\n  }, () => null));\n}\nexport default function App() {\n  _s();\n  // Persisted state via custom hook\n  const [card, setCard] = useLocalStorage(LS_KEYS.CARD, defaultEmptyCard());\n  const [players, setPlayers] = useLocalStorage(LS_KEYS.PLAYERS, []);\n  const [dabbed, setDabbed] = useLocalStorage(LS_KEYS.DABBED, null);\n  const [called, setCalled] = useLocalStorage(LS_KEYS.CALLED, []);\n  const [settings, setSettings] = useLocalStorage(LS_KEYS.SETTINGS, {\n    maxBall: 75,\n    autoMode: false\n  });\n  const [boxes, setBoxes] = useLocalStorage(LS_KEYS.BOXES, []);\n  const [imageUrl, setImageUrl] = useLocalStorage(LS_KEYS.IMAGE_URL, null);\n  const [currentBall, setCurrentBall] = useState(null);\n  const [winnerRow, setWinnerRow] = useState(null);\n\n  // ensure dabbed matrix shape matches card\n  useEffect(() => {\n    var _card$;\n    if (!card) return;\n    const rows = card.length;\n    const cols = ((_card$ = card[0]) === null || _card$ === void 0 ? void 0 : _card$.length) || 0;\n    if (!dabbed || dabbed.length !== rows || dabbed[0].length !== cols) {\n      const newDab = Array.from({\n        length: rows\n      }, () => Array.from({\n        length: cols\n      }, () => false));\n      setDabbed(newDab);\n    }\n  }, [card]);\n\n  // Try to compute a grid layout from OCR boxes by clustering rows and columns\n  const computeGridFromBoxes = boxes => {\n    if (!boxes || boxes.length === 0) return null;\n    // augment boxes with centers and sizes\n    const pts = boxes.map(b => ({\n      ...b,\n      num: parseInt(b.text, 10),\n      cx: (b.bbox.x0 + b.bbox.x1) / 2,\n      cy: (b.bbox.y0 + b.bbox.y1) / 2,\n      w: Math.max(1, b.bbox.x1 - b.bbox.x0),\n      h: Math.max(1, b.bbox.y1 - b.bbox.y0)\n    }));\n\n    // helper median\n    const median = arr => {\n      const s = arr.slice().sort((a, b) => a - b);\n      return s[Math.floor(s.length / 2)] || s[0];\n    };\n    const medianH = median(pts.map(p => p.h)) || 20;\n    const medianW = median(pts.map(p => p.w)) || 20;\n\n    // cluster rows by Y\n    const rowThreshold = medianH * 1.5;\n    const rows = [];\n    pts.slice().sort((a, b) => a.cy - b.cy).forEach(p => {\n      let placed = false;\n      for (const r of rows) {\n        const avg = r.reduce((s, x) => s + x.cy, 0) / r.length;\n        if (Math.abs(p.cy - avg) <= rowThreshold) {\n          r.push(p);\n          placed = true;\n          break;\n        }\n      }\n      if (!placed) rows.push([p]);\n    });\n\n    // columns: cluster x across all points\n    const colThreshold = medianW * 1.5;\n    const cols = [];\n    pts.slice().sort((a, b) => a.cx - b.cx).forEach(p => {\n      let placed = false;\n      for (const c of cols) {\n        const avg = c.reduce((s, x) => s + x.cx, 0) / c.length;\n        if (Math.abs(p.cx - avg) <= colThreshold) {\n          c.push(p);\n          placed = true;\n          break;\n        }\n      }\n      if (!placed) cols.push([p]);\n    });\n\n    // compute column centers\n    const colCenters = cols.map(c => c.reduce((s, x) => s + x.cx, 0) / c.length).sort((a, b) => a - b);\n\n    // build grid rows x colsCount\n    const colsCount = Math.max(1, colCenters.length);\n    const grid = rows.slice().sort((a, b) => a.reduce((s, x) => s + x.cy, 0) / a.length - b.reduce((s, x) => s + x.cy, 0) / b.length).map(r => {\n      const rowArr = Array.from({\n        length: colsCount\n      }, () => null);\n      r.forEach(cell => {\n        // find closest column\n        let bestIdx = 0;\n        let bestDist = Infinity;\n        for (let i = 0; i < colCenters.length; i++) {\n          const d = Math.abs(colCenters[i] - cell.cx);\n          if (d < bestDist) {\n            bestDist = d;\n            bestIdx = i;\n          }\n        }\n        rowArr[bestIdx] = cell.num || null;\n        // annotate the cell with row/col for rendering\n        cell.col = bestIdx;\n      });\n      return rowArr;\n    });\n\n    // annotate row index on pts\n    const annotated = [];\n    rows.forEach((r, ri) => r.forEach(p => annotated.push({\n      ...p,\n      row: ri,\n      col: p.col\n    })));\n\n    // compute row centers\n    const rowCenters = rows.map(r => r.reduce((s, x) => s + x.cy, 0) / r.length);\n    return {\n      grid,\n      annotated,\n      rowCenters,\n      colCenters\n    };\n  };\n\n  // Called when OCR or manual edit produces a new card matrix.\n  const setCardFromOCR = ({\n    rows,\n    boxes: ocrBoxes,\n    imageUrl: imgUrl\n  }) => {\n    // If rows were extracted from text, prefer them (simple case)\n    if (rows && rows.length > 0) {\n      setCard(rows);\n      setBoxes(ocrBoxes);\n      setImageUrl(imgUrl);\n      // reset dabbed when new card loaded\n      const newDab = Array.from({\n        length: rows.length\n      }, () => Array.from({\n        length: rows[0].length\n      }, () => false));\n      setDabbed(newDab);\n      setPlayers(Array.from({\n        length: rows.length\n      }, (_, i) => `Player ${i + 1}`));\n      setCalled([]);\n      setCurrentBall(null);\n      setWinnerRow(null);\n      return;\n    }\n\n    // Try to compute layout from bounding boxes (image-based detection)\n    const layout = computeGridFromBoxes(ocrBoxes);\n    if (layout && layout.grid && layout.grid.length > 0) {\n      setCard(layout.grid);\n      setBoxes(layout.annotated);\n      setImageUrl(imgUrl);\n      const newDab = Array.from({\n        length: layout.grid.length\n      }, () => Array.from({\n        length: layout.grid[0].length\n      }, () => false));\n      setDabbed(newDab);\n      setPlayers(Array.from({\n        length: layout.grid.length\n      }, (_, i) => `Player ${i + 1}`));\n      setCalled([]);\n      setCurrentBall(null);\n      setWinnerRow(null);\n      return;\n    }\n\n    // Fallback: no structured rows, just set empty or text-derived\n    const fallback = rows || defaultEmptyCard();\n    setCard(fallback);\n    setBoxes(ocrBoxes);\n    setImageUrl(imgUrl);\n    const newDab2 = Array.from({\n      length: fallback.length\n    }, () => Array.from({\n      length: fallback[0].length\n    }, () => false));\n    setDabbed(newDab2);\n    setPlayers(Array.from({\n      length: fallback.length\n    }, (_, i) => `Player ${i + 1}`));\n    setCalled([]);\n    setCurrentBall(null);\n    setWinnerRow(null);\n  };\n\n  // toggle dab for a specific cell (manual)\n  const toggleDab = (r, c) => {\n    setDabbed(prev => {\n      const copy = prev.map(row => row.slice());\n      copy[r][c] = !copy[r][c];\n      return copy;\n    });\n  };\n\n  // When a number is called, mark any matching numbers on the card as dabbed (auto)\n  const handleNumberCalled = useCallback((num, {\n    auto\n  } = {\n    auto: false\n  }) => {\n    setCalled(prev => {\n      const next = [...prev, num];\n      return next;\n    });\n    setCurrentBall(num);\n    if (auto) {\n      setDabbed(prev => {\n        const copy = prev.map(row => row.slice());\n        for (let r = 0; r < card.length; r++) {\n          for (let c = 0; c < (card[r] || []).length; c++) {\n            if (String(card[r][c]) === String(num)) copy[r][c] = true;\n          }\n        }\n        return copy;\n      });\n    }\n  }, [card]);\n\n  // On any dab change, check for full-row wins\n  useEffect(() => {\n    if (!dabbed) return;\n    for (let r = 0; r < dabbed.length; r++) {\n      const row = dabbed[r];\n      const all = row.every(Boolean);\n      if (all) {\n        setWinnerRow(r);\n        fireConfetti();\n        break;\n      }\n    }\n  }, [dabbed]);\n  const resetGame = () => {\n    setCalled([]);\n    setCurrentBall(null);\n    setDabbed(prev => prev.map(row => row.map(() => false)));\n    setWinnerRow(null);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app-root\",\n    children: [/*#__PURE__*/_jsxDEV(\"header\", {\n      className: \"topbar\",\n      children: /*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"Custom Bingo\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 227,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 226,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n      className: \"main\",\n      children: [/*#__PURE__*/_jsxDEV(\"section\", {\n        className: \"left\",\n        children: [/*#__PURE__*/_jsxDEV(ImageUploader, {\n          onResult: setCardFromOCR\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 231,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(PlayerList, {\n          players: players,\n          setPlayers: setPlayers\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 232,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(BallPicker, {\n          maxBall: settings.maxBall,\n          setMaxBall: v => setSettings(s => ({\n            ...s,\n            maxBall: v\n          })),\n          autoMode: settings.autoMode,\n          setAutoMode: v => setSettings(s => ({\n            ...s,\n            autoMode: v\n          })),\n          called: called,\n          onCall: num => handleNumberCalled(num, {\n            auto: settings.autoMode\n          }),\n          resetGame: resetGame,\n          currentBall: currentBall\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 233,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 230,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n        className: \"right\",\n        children: /*#__PURE__*/_jsxDEV(CardView, {\n          card: card,\n          players: players,\n          setPlayers: setPlayers,\n          dabbed: dabbed,\n          onToggleDab: toggleDab,\n          manualMode: !settings.autoMode,\n          setCard: setCard,\n          setDabbed: setDabbed,\n          boxes: boxes,\n          imageUrl: imageUrl,\n          setBoxes: setBoxes,\n          setImageUrl: setImageUrl\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 245,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 229,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(WinModal, {\n      open: winnerRow !== null,\n      onClose: () => setWinnerRow(null),\n      winner: {\n        row: winnerRow,\n        player: players[winnerRow]\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 261,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 225,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"BXmHaaIXDuitIfdHcYv99o5aprs=\", false, function () {\n  return [useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage];\n});\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useState","useCallback","ImageUploader","CardView","BallPicker","PlayerList","WinModal","useLocalStorage","fireConfetti","jsxDEV","_jsxDEV","LS_KEYS","CARD","PLAYERS","DABBED","CALLED","SETTINGS","BOXES","IMAGE_URL","defaultEmptyCard","rows","cols","Array","from","length","App","_s","card","setCard","players","setPlayers","dabbed","setDabbed","called","setCalled","settings","setSettings","maxBall","autoMode","boxes","setBoxes","imageUrl","setImageUrl","currentBall","setCurrentBall","winnerRow","setWinnerRow","_card$","newDab","computeGridFromBoxes","pts","map","b","num","parseInt","text","cx","bbox","x0","x1","cy","y0","y1","w","Math","max","h","median","arr","s","slice","sort","a","floor","medianH","p","medianW","rowThreshold","forEach","placed","r","avg","reduce","x","abs","push","colThreshold","c","colCenters","colsCount","grid","rowArr","cell","bestIdx","bestDist","Infinity","i","d","col","annotated","ri","row","rowCenters","setCardFromOCR","ocrBoxes","imgUrl","_","layout","fallback","newDab2","toggleDab","prev","copy","handleNumberCalled","auto","next","String","all","every","Boolean","resetGame","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onResult","setMaxBall","v","setAutoMode","onCall","onToggleDab","manualMode","open","onClose","winner","player","_c","$RefreshReg$"],"sources":["C:/Users/Rande/bingocaller/src/App.js"],"sourcesContent":["/*\n  src/App.js\n  Main application container. Coordinates OCR upload, card state,\n  ball picker, dab logic, auto/manual modes, and win detection.\n*/\nimport React, { useEffect, useState, useCallback } from 'react'\nimport ImageUploader from './components/ImageUploader'\nimport CardView from './components/CardView'\nimport BallPicker from './components/BallPicker'\nimport PlayerList from './components/PlayerList'\nimport WinModal from './components/WinModal'\nimport { useLocalStorage } from './hooks/useLocalStorage'\nimport { fireConfetti } from './utils/confetti'\n\n// Keys for localStorage\nconst LS_KEYS = {\n  CARD: 'bingo_card',\n  PLAYERS: 'bingo_players',\n  DABBED: 'bingo_dabbed',\n  CALLED: 'bingo_called',\n  SETTINGS: 'bingo_settings',\n  BOXES: 'bingo_boxes',\n  IMAGE_URL: 'bingo_image_url'\n}\n\nfunction defaultEmptyCard(rows = 5, cols = 5) {\n  // generate an empty card of placeholders (null means empty cell)\n  return Array.from({ length: rows }, () => Array.from({ length: cols }, () => null))\n}\n\nexport default function App() {\n  // Persisted state via custom hook\n  const [card, setCard] = useLocalStorage(LS_KEYS.CARD, defaultEmptyCard())\n  const [players, setPlayers] = useLocalStorage(LS_KEYS.PLAYERS, [])\n  const [dabbed, setDabbed] = useLocalStorage(LS_KEYS.DABBED, null)\n  const [called, setCalled] = useLocalStorage(LS_KEYS.CALLED, [])\n  const [settings, setSettings] = useLocalStorage(LS_KEYS.SETTINGS, { maxBall: 75, autoMode: false })\n  const [boxes, setBoxes] = useLocalStorage(LS_KEYS.BOXES, [])\n  const [imageUrl, setImageUrl] = useLocalStorage(LS_KEYS.IMAGE_URL, null)\n\n  const [currentBall, setCurrentBall] = useState(null)\n  const [winnerRow, setWinnerRow] = useState(null)\n\n  // ensure dabbed matrix shape matches card\n  useEffect(() => {\n    if (!card) return\n    const rows = card.length\n    const cols = card[0]?.length || 0\n    if (!dabbed || dabbed.length !== rows || dabbed[0].length !== cols) {\n      const newDab = Array.from({ length: rows }, () => Array.from({ length: cols }, () => false))\n      setDabbed(newDab)\n    }\n  }, [card])\n\n  // Try to compute a grid layout from OCR boxes by clustering rows and columns\n  const computeGridFromBoxes = (boxes) => {\n    if (!boxes || boxes.length === 0) return null\n    // augment boxes with centers and sizes\n    const pts = boxes.map(b => ({\n      ...b,\n      num: parseInt(b.text, 10),\n      cx: (b.bbox.x0 + b.bbox.x1) / 2,\n      cy: (b.bbox.y0 + b.bbox.y1) / 2,\n      w: Math.max(1, b.bbox.x1 - b.bbox.x0),\n      h: Math.max(1, b.bbox.y1 - b.bbox.y0)\n    }))\n\n    // helper median\n    const median = (arr) => { const s = arr.slice().sort((a,b)=>a-b); return s[Math.floor(s.length/2)] || s[0] }\n    const medianH = median(pts.map(p=>p.h)) || 20\n    const medianW = median(pts.map(p=>p.w)) || 20\n\n    // cluster rows by Y\n    const rowThreshold = medianH * 1.5\n    const rows = []\n    pts.slice().sort((a,b)=>a.cy-b.cy).forEach(p => {\n      let placed = false\n      for (const r of rows) {\n        const avg = r.reduce((s,x)=>s + x.cy, 0) / r.length\n        if (Math.abs(p.cy - avg) <= rowThreshold) { r.push(p); placed = true; break }\n      }\n      if (!placed) rows.push([p])\n    })\n\n    // columns: cluster x across all points\n    const colThreshold = medianW * 1.5\n    const cols = []\n    pts.slice().sort((a,b)=>a.cx-b.cx).forEach(p => {\n      let placed = false\n      for (const c of cols) {\n        const avg = c.reduce((s,x)=>s + x.cx, 0) / c.length\n        if (Math.abs(p.cx - avg) <= colThreshold) { c.push(p); placed = true; break }\n      }\n      if (!placed) cols.push([p])\n    })\n\n    // compute column centers\n    const colCenters = cols.map(c => c.reduce((s,x)=>s + x.cx, 0) / c.length).sort((a,b)=>a-b)\n\n    // build grid rows x colsCount\n    const colsCount = Math.max(1, colCenters.length)\n    const grid = rows.slice().sort((a,b)=> (a.reduce((s,x)=>s + x.cy,0)/a.length) - (b.reduce((s,x)=>s + x.cy,0)/b.length)).map(r => {\n      const rowArr = Array.from({ length: colsCount }, () => null)\n      r.forEach(cell => {\n        // find closest column\n        let bestIdx = 0\n        let bestDist = Infinity\n        for (let i = 0; i < colCenters.length; i++) {\n          const d = Math.abs(colCenters[i] - cell.cx)\n          if (d < bestDist) { bestDist = d; bestIdx = i }\n        }\n        rowArr[bestIdx] = cell.num || null\n        // annotate the cell with row/col for rendering\n        cell.col = bestIdx\n      })\n      return rowArr\n    })\n\n    // annotate row index on pts\n    const annotated = []\n    rows.forEach((r, ri) => r.forEach(p => annotated.push({ ...p, row: ri, col: p.col })) )\n\n    // compute row centers\n    const rowCenters = rows.map(r => r.reduce((s,x)=>s + x.cy,0) / r.length)\n\n    return { grid, annotated, rowCenters, colCenters }\n  }\n\n  // Called when OCR or manual edit produces a new card matrix.\n  const setCardFromOCR = ({ rows, boxes: ocrBoxes, imageUrl: imgUrl }) => {\n    // If rows were extracted from text, prefer them (simple case)\n    if (rows && rows.length > 0) {\n      setCard(rows)\n      setBoxes(ocrBoxes)\n      setImageUrl(imgUrl)\n      // reset dabbed when new card loaded\n      const newDab = Array.from({ length: rows.length }, () => Array.from({ length: rows[0].length }, () => false))\n      setDabbed(newDab)\n      setPlayers(Array.from({ length: rows.length }, (_, i) => `Player ${i + 1}`))\n      setCalled([])\n      setCurrentBall(null)\n      setWinnerRow(null)\n      return\n    }\n\n    // Try to compute layout from bounding boxes (image-based detection)\n    const layout = computeGridFromBoxes(ocrBoxes)\n    if (layout && layout.grid && layout.grid.length > 0) {\n      setCard(layout.grid)\n      setBoxes(layout.annotated)\n      setImageUrl(imgUrl)\n      const newDab = Array.from({ length: layout.grid.length }, () => Array.from({ length: layout.grid[0].length }, () => false))\n      setDabbed(newDab)\n      setPlayers(Array.from({ length: layout.grid.length }, (_, i) => `Player ${i + 1}`))\n      setCalled([])\n      setCurrentBall(null)\n      setWinnerRow(null)\n      return\n    }\n\n    // Fallback: no structured rows, just set empty or text-derived\n    const fallback = rows || defaultEmptyCard()\n    setCard(fallback)\n    setBoxes(ocrBoxes)\n    setImageUrl(imgUrl)\n    const newDab2 = Array.from({ length: fallback.length }, () => Array.from({ length: fallback[0].length }, () => false))\n    setDabbed(newDab2)\n    setPlayers(Array.from({ length: fallback.length }, (_, i) => `Player ${i + 1}`))\n    setCalled([])\n    setCurrentBall(null)\n    setWinnerRow(null)\n  }\n\n  // toggle dab for a specific cell (manual)\n  const toggleDab = (r, c) => {\n    setDabbed(prev => {\n      const copy = prev.map(row => row.slice())\n      copy[r][c] = !copy[r][c]\n      return copy\n    })\n  }\n\n  // When a number is called, mark any matching numbers on the card as dabbed (auto)\n  const handleNumberCalled = useCallback((num, { auto } = { auto: false }) => {\n    setCalled(prev => {\n      const next = [...prev, num]\n      return next\n    })\n    setCurrentBall(num)\n    if (auto) {\n      setDabbed(prev => {\n        const copy = prev.map(row => row.slice())\n        for (let r = 0; r < card.length; r++) {\n          for (let c = 0; c < (card[r] || []).length; c++) {\n            if (String(card[r][c]) === String(num)) copy[r][c] = true\n          }\n        }\n        return copy\n      })\n    }\n  }, [card])\n\n  // On any dab change, check for full-row wins\n  useEffect(() => {\n    if (!dabbed) return\n    for (let r = 0; r < dabbed.length; r++) {\n      const row = dabbed[r]\n      const all = row.every(Boolean)\n      if (all) {\n        setWinnerRow(r)\n        fireConfetti()\n        break\n      }\n    }\n  }, [dabbed])\n\n  const resetGame = () => {\n    setCalled([])\n    setCurrentBall(null)\n    setDabbed(prev => prev.map(row => row.map(() => false)))\n    setWinnerRow(null)\n  }\n\n  return (\n    <div className=\"app-root\">\n      <header className=\"topbar\">\n        <h1>Custom Bingo</h1>\n      </header>\n      <main className=\"main\">\n        <section className=\"left\">\n          <ImageUploader onResult={setCardFromOCR} />\n          <PlayerList players={players} setPlayers={setPlayers} />\n          <BallPicker\n            maxBall={settings.maxBall}\n            setMaxBall={(v) => setSettings(s => ({ ...s, maxBall: v }))}\n            autoMode={settings.autoMode}\n            setAutoMode={(v) => setSettings(s => ({ ...s, autoMode: v }))}\n            called={called}\n            onCall={(num) => handleNumberCalled(num, { auto: settings.autoMode })}\n            resetGame={resetGame}\n            currentBall={currentBall}\n          />\n        </section>\n        <section className=\"right\">\n          <CardView\n            card={card}\n            players={players}\n            setPlayers={setPlayers}\n            dabbed={dabbed}\n            onToggleDab={toggleDab}\n            manualMode={!settings.autoMode}\n            setCard={setCard}\n            setDabbed={setDabbed}\n            boxes={boxes}\n            imageUrl={imageUrl}\n            setBoxes={setBoxes}\n            setImageUrl={setImageUrl}\n          />\n        </section>\n      </main>\n      <WinModal\n        open={winnerRow !== null}\n        onClose={() => setWinnerRow(null)}\n        winner={{ row: winnerRow, player: players[winnerRow] }}\n      />\n    </div>\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}