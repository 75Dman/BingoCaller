{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Rande\\\\bingocaller\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\n/*\n  src/App.js\n  Main application container. Coordinates OCR upload, card state,\n  ball picker, dab logic, auto/manual modes, and win detection.\n*/\nimport React, { useEffect, useState, useCallback } from 'react';\nimport ImageUploader from './components/ImageUploader';\nimport CardView from './components/CardView';\nimport BallPicker from './components/BallPicker';\nimport PlayerList from './components/PlayerList';\nimport DabOverlayControls from './components/DabOverlayControls';\nimport GridDesigner from './components/GridDesigner';\nimport WinModal from './components/WinModal';\nimport { useLocalStorage } from './hooks/useLocalStorage';\nimport { fireConfetti } from './utils/confetti';\n\n// Keys for localStorage\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst LS_KEYS = {\n  CARD: 'bingo_card',\n  PLAYERS: 'bingo_players',\n  DABBED: 'bingo_dabbed',\n  CALLED: 'bingo_called',\n  SETTINGS: 'bingo_settings'\n};\nfunction defaultEmptyCard(rows = 5, cols = 5) {\n  // generate an empty card of placeholders (null means empty cell)\n  return Array.from({\n    length: rows\n  }, () => Array.from({\n    length: cols\n  }, () => null));\n}\nexport default function App() {\n  _s();\n  // Persisted state via custom hook\n  const [card, setCard] = useLocalStorage(LS_KEYS.CARD, defaultEmptyCard());\n  const [players, setPlayers] = useLocalStorage(LS_KEYS.PLAYERS, []);\n  // separate persisted lists for row/column players (to support player-only overlays)\n  const [playersRows, setPlayersRows] = useLocalStorage('bingo_players_rows', []);\n  const [playersCols, setPlayersCols] = useLocalStorage('bingo_players_cols', []);\n  // defaults to control whether row/col player labels are shown by default\n  const [gridDefaults, setGridDefaults] = useLocalStorage('bingo_grid_defaults', {\n    rows: 20,\n    cols: 5,\n    order: 'column',\n    scrambled: false,\n    firstNum: 1,\n    overlayType: 'dab',\n    playerCount: 20,\n    playerRowOffset: 110,\n    playerColOffset: 36,\n    showPlayerRows: true,\n    showPlayerCols: false\n  });\n  const [dabbed, setDabbed] = useLocalStorage(LS_KEYS.DABBED, null);\n  const [called, setCalled] = useLocalStorage(LS_KEYS.CALLED, []);\n  const [settings, setSettings] = useLocalStorage(LS_KEYS.SETTINGS, {\n    maxBall: 75,\n    autoMode: false\n  });\n  // persisted image reference: either a data URL, http URL, or an \"indexeddb:<key>\" marker\n  const [imageRef, setImageRef] = useLocalStorage('bingo_image_url', null);\n  // derived display URL (not persisted) used for rendering the <img src>\n  const [displayImageUrl, setDisplayImageUrl] = useState(null);\n  useEffect(() => {\n    // Guard against stale blob: URLs persisted to localStorage from previous sessions.\n    if (imageRef && typeof imageRef === 'string' && imageRef.startsWith('blob:')) {\n      console.debug('[App] Clearing stale blob URL from persisted imageRef');\n      setImageRef(null);\n    }\n  }, [imageRef, setImageRef]);\n\n  // If we get an indexeddb: marker, load it from IndexedDB and convert to data URL for display\n  useEffect(() => {\n    let cancelled = false;\n    async function resolveImage() {\n      if (!imageRef) {\n        setDisplayImageUrl(null);\n        return;\n      }\n      if (typeof imageRef === 'string' && imageRef.startsWith('indexeddb:')) {\n        const key = imageRef.slice('indexeddb:'.length);\n        try {\n          const {\n            getFile\n          } = await import('./utils/idb');\n          const file = await getFile(key);\n          if (!file) {\n            console.warn('[App] indexedDB entry not found for', key);\n            if (!cancelled) setImageRef(null);\n            return;\n          }\n          // convert file to dataURL\n          const dataURL = await new Promise((resolve, reject) => {\n            const fr = new FileReader();\n            fr.onload = () => resolve(fr.result);\n            fr.onerror = reject;\n            fr.readAsDataURL(file);\n          });\n          if (!cancelled) setDisplayImageUrl(dataURL);\n        } catch (err) {\n          console.error('Error loading image from indexedDB', err);\n          if (!cancelled) setImageRef(null);\n        }\n      } else {\n        // regular URL or data URL\n        setDisplayImageUrl(imageRef);\n      }\n    }\n    resolveImage();\n    return () => {\n      cancelled = true;\n    };\n  }, [imageRef, setImageRef]);\n  const [currentBall, setCurrentBall] = useState(null);\n  const [winner, setWinner] = useState(null);\n\n  // dab overlay grid state\n  const [gridDesignerOpen, setGridDesignerOpen] = useState(false);\n  const [grid, setGrid] = useLocalStorage('bingo_grid', null);\n  // defaults for designer (persisted)\n  // (gridDefaults declared earlier with player show flags)\n\n  // ensure dabbed matrix shape matches card\n  useEffect(() => {\n    var _card$;\n    if (!card) return;\n    const rows = card.length;\n    const cols = ((_card$ = card[0]) === null || _card$ === void 0 ? void 0 : _card$.length) || 0;\n\n    // If the current grid does not include dab, explicitly clear any persisted dab state\n    if (!((grid === null || grid === void 0 ? void 0 : grid.overlayType) === 'dab' || (grid === null || grid === void 0 ? void 0 : grid.overlayType) === 'both')) {\n      if (dabbed !== null) {\n        console.debug('[App] Clearing persisted dab state because overlay is not dab/both');\n        setDabbed(null);\n      }\n      return;\n    }\n\n    // Otherwise ensure dabbed matrix shape matches card\n    if (!dabbed || dabbed.length !== rows || dabbed[0].length !== cols) {\n      const newDab = Array.from({\n        length: rows\n      }, () => Array.from({\n        length: cols\n      }, () => false));\n      setDabbed(newDab);\n    }\n  }, [card, grid]);\n\n  // Called when OCR or manual edit produces a new card matrix.\n  const setCardFromOCR = ({\n    rows,\n    imageUrl: imgUrl\n  }) => {\n    // If rows were extracted from text, prefer them (simple case)\n    if (rows && rows.length > 0) {\n      setCard(rows);\n      setImageRef(imgUrl);\n      // reset dabbed when new card loaded ONLY when current grid overlay includes dab\n      if ((grid === null || grid === void 0 ? void 0 : grid.overlayType) === 'dab' || (grid === null || grid === void 0 ? void 0 : grid.overlayType) === 'both') {\n        const newDab = Array.from({\n          length: rows.length\n        }, () => Array.from({\n          length: rows[0].length\n        }, () => false));\n        setDabbed(newDab);\n      } else {\n        setDabbed(null);\n      }\n      // do NOT automatically change players or detect rows anymore\n      setCalled([]);\n      setCurrentBall(null);\n      setWinner(null);\n      return;\n    }\n\n    // Fallback: no structured rows, just set empty or text-derived\n    const fallback = rows || defaultEmptyCard();\n    setCard(fallback);\n    setImageRef(imgUrl);\n    if ((grid === null || grid === void 0 ? void 0 : grid.overlayType) === 'dab' || (grid === null || grid === void 0 ? void 0 : grid.overlayType) === 'both') {\n      const newDab2 = Array.from({\n        length: fallback.length\n      }, () => Array.from({\n        length: fallback[0].length\n      }, () => false));\n      setDabbed(newDab2);\n    } else {\n      setDabbed(null);\n    }\n    setCalled([]);\n    setCurrentBall(null);\n    setWinner(null);\n    return;\n  };\n\n  // Grid designer actions\n  const openGridDesigner = () => setGridDesignerOpen(true);\n  const closeGridDesigner = () => setGridDesignerOpen(false);\n  const clearGrid = () => {\n    setGrid(null);\n  };\n  const saveGrid = g => {\n    // g: { bbox, rows, cols, numbering, values, overlayType }\n    setGrid(g);\n    // populate card matrix from values\n    if (g && g.values) {\n      setCard(g.values);\n      // initialize dabbed only when overlayType includes dab\n      if (g.overlayType === 'dab' || g.overlayType === 'both') {\n        setDabbed(Array.from({\n          length: g.rows\n        }, () => Array.from({\n          length: g.cols\n        }, () => false)));\n      } else {\n        // explicitly clear any existing dabbed state when saving a player-only overlay\n        setDabbed(null);\n      }\n      // update global player lists based on what the designer saved (if present)\n      if (g.playerOverlay) {\n        if (g.playerOverlay.showRows) setPlayersRows(g.playerOverlay.rows.slice(0, g.rows));\n        if (g.playerOverlay.showCols) setPlayersCols(g.playerOverlay.cols.slice(0, g.cols));\n      }\n    }\n    // If overlay doesn't include dab, also ensure any previous winner state is cleared\n    if (!(g.overlayType === 'dab' || g.overlayType === 'both')) {\n      setWinner(null);\n      setCalled([]);\n      setCurrentBall(null);\n    }\n    setGridDesignerOpen(false);\n  };\n\n  // toggle dab for a specific cell (manual)\n  const toggleDab = (r, c) => {\n    // if dab overlay is not active/initialized, ignore manual toggles\n    if (!dabbed) return;\n    setDabbed(prev => {\n      const copy = prev.map(row => row.slice());\n      copy[r][c] = !copy[r][c];\n      return copy;\n    });\n  };\n\n  // When a number is called, mark any matching numbers on the card as dabbed (auto)\n  const handleNumberCalled = useCallback((num, {\n    auto\n  } = {\n    auto: false\n  }) => {\n    setCalled(prev => {\n      const next = [...prev, num];\n      return next;\n    });\n    setCurrentBall(num);\n    if (auto && dabbed) {\n      setDabbed(prev => {\n        const copy = prev.map(row => row.slice());\n        for (let r = 0; r < card.length; r++) {\n          for (let c = 0; c < (card[r] || []).length; c++) {\n            if (String(card[r][c]) === String(num)) copy[r][c] = true;\n          }\n        }\n        return copy;\n      });\n    }\n  }, [card, dabbed]);\n\n  // On any dab change, check for full-row wins\n  useEffect(() => {\n    var _dabbed$;\n    if (!dabbed) return;\n    // check rows\n    for (let r = 0; r < dabbed.length; r++) {\n      const row = dabbed[r];\n      const all = row.every(Boolean);\n      if (all) {\n        var _grid$playerOverlay, _grid$playerOverlay$r;\n        const player = grid === null || grid === void 0 ? void 0 : (_grid$playerOverlay = grid.playerOverlay) === null || _grid$playerOverlay === void 0 ? void 0 : (_grid$playerOverlay$r = _grid$playerOverlay.rows) === null || _grid$playerOverlay$r === void 0 ? void 0 : _grid$playerOverlay$r[r];\n        setWinner({\n          axis: 'row',\n          index: r,\n          player\n        });\n        fireConfetti();\n        return;\n      }\n    }\n    // check columns\n    const cols = ((_dabbed$ = dabbed[0]) === null || _dabbed$ === void 0 ? void 0 : _dabbed$.length) || 0;\n    for (let c = 0; c < cols; c++) {\n      let all = true;\n      for (let r = 0; r < dabbed.length; r++) {\n        if (!dabbed[r][c]) {\n          all = false;\n          break;\n        }\n      }\n      if (all) {\n        var _grid$playerOverlay2, _grid$playerOverlay2$;\n        const player = grid === null || grid === void 0 ? void 0 : (_grid$playerOverlay2 = grid.playerOverlay) === null || _grid$playerOverlay2 === void 0 ? void 0 : (_grid$playerOverlay2$ = _grid$playerOverlay2.cols) === null || _grid$playerOverlay2$ === void 0 ? void 0 : _grid$playerOverlay2$[c];\n        setWinner({\n          axis: 'col',\n          index: c,\n          player\n        });\n        fireConfetti();\n        return;\n      }\n    }\n  }, [dabbed, grid]);\n  const resetGame = () => {\n    setCalled([]);\n    setCurrentBall(null);\n    if (dabbed) setDabbed(prev => prev.map(row => row.map(() => false)));\n    setWinner(null);\n  };\n  const toggleDabLine = (axis, idx) => {\n    // ignore if dab overlay not present\n    if (!dabbed) return;\n    setDabbed(prev => {\n      const copy = prev.map(r => r.slice());\n      if (axis === 'row') {\n        const all = copy[idx].every(Boolean);\n        for (let c = 0; c < copy[idx].length; c++) copy[idx][c] = !all;\n      } else {\n        // col\n        const rows = copy.length;\n        let all = true;\n        for (let r = 0; r < rows; r++) if (!copy[r][idx]) {\n          all = false;\n          break;\n        }\n        for (let r = 0; r < rows; r++) copy[r][idx] = !all;\n      }\n      return copy;\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app-root\",\n    children: [/*#__PURE__*/_jsxDEV(\"header\", {\n      className: \"topbar\",\n      children: /*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"Custom Bingo\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 279,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 278,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"main\", {\n      className: \"main\",\n      children: [/*#__PURE__*/_jsxDEV(\"section\", {\n        className: \"left\",\n        children: [/*#__PURE__*/_jsxDEV(ImageUploader, {\n          onResult: setCardFromOCR\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 283,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(DabOverlayControls, {\n          grid: grid,\n          defaults: gridDefaults,\n          setDefaults: setGridDefaults,\n          onDesign: openGridDesigner,\n          onClear: clearGrid,\n          playersRows: playersRows,\n          setPlayersRows: setPlayersRows,\n          playersCols: playersCols,\n          setPlayersCols: setPlayersCols\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 284,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(PlayerList, {\n          playersRows: playersRows,\n          setPlayersRows: setPlayersRows,\n          playersCols: playersCols,\n          setPlayersCols: setPlayersCols,\n          showRows: gridDefaults === null || gridDefaults === void 0 ? void 0 : gridDefaults.showPlayerRows,\n          setShowRows: v => setGridDefaults(d => ({\n            ...d,\n            showPlayerRows: v\n          })),\n          showCols: gridDefaults === null || gridDefaults === void 0 ? void 0 : gridDefaults.showPlayerCols,\n          setShowCols: v => setGridDefaults(d => ({\n            ...d,\n            showPlayerCols: v\n          }))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 285,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(BallPicker, {\n          maxBall: settings.maxBall,\n          setMaxBall: v => setSettings(s => ({\n            ...s,\n            maxBall: v\n          })),\n          autoMode: settings.autoMode,\n          setAutoMode: v => setSettings(s => ({\n            ...s,\n            autoMode: v\n          })),\n          called: called,\n          onCall: num => handleNumberCalled(num, {\n            auto: settings.autoMode\n          }),\n          resetGame: resetGame,\n          currentBall: currentBall\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 286,\n          columnNumber: 11\n        }, this), gridDesignerOpen && /*#__PURE__*/_jsxDEV(GridDesigner, {\n          imageUrl: displayImageUrl,\n          initialGrid: grid,\n          initialDefaults: gridDefaults,\n          onSave: saveGrid,\n          onCancel: closeGridDesigner,\n          playersRows: playersRows,\n          setPlayersRows: setPlayersRows,\n          playersCols: playersCols,\n          setPlayersCols: setPlayersCols\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 297,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 282,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n        className: \"right\",\n        children: /*#__PURE__*/_jsxDEV(CardView, {\n          card: card,\n          playersRows: playersRows,\n          setPlayersRows: setPlayersRows,\n          playersCols: playersCols,\n          setPlayersCols: setPlayersCols,\n          dabbed: dabbed,\n          onToggleDab: toggleDab,\n          onToggleDabLine: toggleDabLine,\n          manualMode: !settings.autoMode,\n          setCard: setCard,\n          setDabbed: setDabbed,\n          imageUrl: displayImageUrl,\n          grid: grid\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 301,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 300,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 281,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(WinModal, {\n      open: winner !== null,\n      onClose: () => setWinner(null),\n      winner: winner\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 318,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 277,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"oA2YU69riTYW2rxhyo8duuEtNPo=\", false, function () {\n  return [useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage, useLocalStorage];\n});\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useEffect","useState","useCallback","ImageUploader","CardView","BallPicker","PlayerList","DabOverlayControls","GridDesigner","WinModal","useLocalStorage","fireConfetti","jsxDEV","_jsxDEV","LS_KEYS","CARD","PLAYERS","DABBED","CALLED","SETTINGS","defaultEmptyCard","rows","cols","Array","from","length","App","_s","card","setCard","players","setPlayers","playersRows","setPlayersRows","playersCols","setPlayersCols","gridDefaults","setGridDefaults","order","scrambled","firstNum","overlayType","playerCount","playerRowOffset","playerColOffset","showPlayerRows","showPlayerCols","dabbed","setDabbed","called","setCalled","settings","setSettings","maxBall","autoMode","imageRef","setImageRef","displayImageUrl","setDisplayImageUrl","startsWith","console","debug","cancelled","resolveImage","key","slice","getFile","file","warn","dataURL","Promise","resolve","reject","fr","FileReader","onload","result","onerror","readAsDataURL","err","error","currentBall","setCurrentBall","winner","setWinner","gridDesignerOpen","setGridDesignerOpen","grid","setGrid","_card$","newDab","setCardFromOCR","imageUrl","imgUrl","fallback","newDab2","openGridDesigner","closeGridDesigner","clearGrid","saveGrid","g","values","playerOverlay","showRows","showCols","toggleDab","r","c","prev","copy","map","row","handleNumberCalled","num","auto","next","String","_dabbed$","all","every","Boolean","_grid$playerOverlay","_grid$playerOverlay$r","player","axis","index","_grid$playerOverlay2","_grid$playerOverlay2$","resetGame","toggleDabLine","idx","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onResult","defaults","setDefaults","onDesign","onClear","setShowRows","v","d","setShowCols","setMaxBall","s","setAutoMode","onCall","initialGrid","initialDefaults","onSave","onCancel","onToggleDab","onToggleDabLine","manualMode","open","onClose","_c","$RefreshReg$"],"sources":["C:/Users/Rande/bingocaller/src/App.js"],"sourcesContent":["/*\n  src/App.js\n  Main application container. Coordinates OCR upload, card state,\n  ball picker, dab logic, auto/manual modes, and win detection.\n*/\nimport React, { useEffect, useState, useCallback } from 'react'\nimport ImageUploader from './components/ImageUploader'\nimport CardView from './components/CardView'\nimport BallPicker from './components/BallPicker'\nimport PlayerList from './components/PlayerList'\nimport DabOverlayControls from './components/DabOverlayControls'\nimport GridDesigner from './components/GridDesigner'\nimport WinModal from './components/WinModal'\nimport { useLocalStorage } from './hooks/useLocalStorage'\nimport { fireConfetti } from './utils/confetti'\n\n// Keys for localStorage\nconst LS_KEYS = {\n  CARD: 'bingo_card',\n  PLAYERS: 'bingo_players',\n  DABBED: 'bingo_dabbed',\n  CALLED: 'bingo_called',\n  SETTINGS: 'bingo_settings'\n}\n\nfunction defaultEmptyCard(rows = 5, cols = 5) {\n  // generate an empty card of placeholders (null means empty cell)\n  return Array.from({ length: rows }, () => Array.from({ length: cols }, () => null))\n}\n\nexport default function App() {\n  // Persisted state via custom hook\n  const [card, setCard] = useLocalStorage(LS_KEYS.CARD, defaultEmptyCard())\n  const [players, setPlayers] = useLocalStorage(LS_KEYS.PLAYERS, [])\n  // separate persisted lists for row/column players (to support player-only overlays)\n  const [playersRows, setPlayersRows] = useLocalStorage('bingo_players_rows', [])\n  const [playersCols, setPlayersCols] = useLocalStorage('bingo_players_cols', [])\n  // defaults to control whether row/col player labels are shown by default\n  const [gridDefaults, setGridDefaults] = useLocalStorage('bingo_grid_defaults', { rows: 20, cols: 5, order: 'column', scrambled: false, firstNum: 1, overlayType: 'dab', playerCount: 20, playerRowOffset: 110, playerColOffset: 36, showPlayerRows: true, showPlayerCols: false })\n  const [dabbed, setDabbed] = useLocalStorage(LS_KEYS.DABBED, null)\n  const [called, setCalled] = useLocalStorage(LS_KEYS.CALLED, [])\n  const [settings, setSettings] = useLocalStorage(LS_KEYS.SETTINGS, { maxBall: 75, autoMode: false })\n  // persisted image reference: either a data URL, http URL, or an \"indexeddb:<key>\" marker\n  const [imageRef, setImageRef] = useLocalStorage('bingo_image_url', null)\n  // derived display URL (not persisted) used for rendering the <img src>\n  const [displayImageUrl, setDisplayImageUrl] = useState(null)\n\n  useEffect(() => {\n    // Guard against stale blob: URLs persisted to localStorage from previous sessions.\n    if (imageRef && typeof imageRef === 'string' && imageRef.startsWith('blob:')) {\n      console.debug('[App] Clearing stale blob URL from persisted imageRef')\n      setImageRef(null)\n    }\n  }, [imageRef, setImageRef])\n\n  // If we get an indexeddb: marker, load it from IndexedDB and convert to data URL for display\n  useEffect(() => {\n    let cancelled = false\n    async function resolveImage() {\n      if (!imageRef) { setDisplayImageUrl(null); return }\n      if (typeof imageRef === 'string' && imageRef.startsWith('indexeddb:')) {\n        const key = imageRef.slice('indexeddb:'.length)\n        try {\n          const { getFile } = await import('./utils/idb')\n          const file = await getFile(key)\n          if (!file) {\n            console.warn('[App] indexedDB entry not found for', key)\n            if (!cancelled) setImageRef(null)\n            return\n          }\n          // convert file to dataURL\n          const dataURL = await new Promise((resolve, reject) => {\n            const fr = new FileReader(); fr.onload = () => resolve(fr.result); fr.onerror = reject; fr.readAsDataURL(file)\n          })\n          if (!cancelled) setDisplayImageUrl(dataURL)\n        } catch (err) {\n          console.error('Error loading image from indexedDB', err)\n          if (!cancelled) setImageRef(null)\n        }\n      } else {\n        // regular URL or data URL\n        setDisplayImageUrl(imageRef)\n      }\n    }\n    resolveImage()\n    return () => { cancelled = true }\n  }, [imageRef, setImageRef])\n\n  const [currentBall, setCurrentBall] = useState(null)\n  const [winner, setWinner] = useState(null)\n\n  // dab overlay grid state\n  const [gridDesignerOpen, setGridDesignerOpen] = useState(false)\n  const [grid, setGrid] = useLocalStorage('bingo_grid', null)\n  // defaults for designer (persisted)\n  // (gridDefaults declared earlier with player show flags)\n\n  // ensure dabbed matrix shape matches card\n  useEffect(() => {\n    if (!card) return\n    const rows = card.length\n    const cols = card[0]?.length || 0\n\n    // If the current grid does not include dab, explicitly clear any persisted dab state\n    if (!(grid?.overlayType === 'dab' || grid?.overlayType === 'both')) {\n      if (dabbed !== null) {\n        console.debug('[App] Clearing persisted dab state because overlay is not dab/both')\n        setDabbed(null)\n      }\n      return\n    }\n\n    // Otherwise ensure dabbed matrix shape matches card\n    if (!dabbed || dabbed.length !== rows || dabbed[0].length !== cols) {\n      const newDab = Array.from({ length: rows }, () => Array.from({ length: cols }, () => false))\n      setDabbed(newDab)\n    }\n  }, [card, grid])\n\n  // Called when OCR or manual edit produces a new card matrix.\n  const setCardFromOCR = ({ rows, imageUrl: imgUrl }) => {\n    // If rows were extracted from text, prefer them (simple case)\n    if (rows && rows.length > 0) {\n      setCard(rows)\n      setImageRef(imgUrl)\n      // reset dabbed when new card loaded ONLY when current grid overlay includes dab\n      if (grid?.overlayType === 'dab' || grid?.overlayType === 'both') {\n        const newDab = Array.from({ length: rows.length }, () => Array.from({ length: rows[0].length }, () => false))\n        setDabbed(newDab)\n      } else {\n        setDabbed(null)\n      }\n      // do NOT automatically change players or detect rows anymore\n      setCalled([])\n      setCurrentBall(null)\n      setWinner(null)\n      return\n    }\n\n    // Fallback: no structured rows, just set empty or text-derived\n    const fallback = rows || defaultEmptyCard()\n    setCard(fallback)\n    setImageRef(imgUrl)\n    if (grid?.overlayType === 'dab' || grid?.overlayType === 'both') {\n      const newDab2 = Array.from({ length: fallback.length }, () => Array.from({ length: fallback[0].length }, () => false))\n      setDabbed(newDab2)\n    } else {\n      setDabbed(null)\n    }\n    setCalled([])\n    setCurrentBall(null)\n    setWinner(null)\n    return\n  }\n\n  // Grid designer actions\n  const openGridDesigner = () => setGridDesignerOpen(true)\n  const closeGridDesigner = () => setGridDesignerOpen(false)\n  const clearGrid = () => { setGrid(null) }\n\n  const saveGrid = (g) => {\n    // g: { bbox, rows, cols, numbering, values, overlayType }\n    setGrid(g)\n    // populate card matrix from values\n      if (g && g.values) {\n      setCard(g.values)\n      // initialize dabbed only when overlayType includes dab\n      if (g.overlayType === 'dab' || g.overlayType === 'both') {\n        setDabbed(Array.from({ length: g.rows }, () => Array.from({ length: g.cols }, () => false)))\n      } else {\n        // explicitly clear any existing dabbed state when saving a player-only overlay\n        setDabbed(null)\n      }\n      // update global player lists based on what the designer saved (if present)\n      if (g.playerOverlay) {\n        if (g.playerOverlay.showRows) setPlayersRows(g.playerOverlay.rows.slice(0, g.rows))\n        if (g.playerOverlay.showCols) setPlayersCols(g.playerOverlay.cols.slice(0, g.cols))\n      }\n    }\n    // If overlay doesn't include dab, also ensure any previous winner state is cleared\n    if (!(g.overlayType === 'dab' || g.overlayType === 'both')) {\n      setWinner(null)\n      setCalled([])\n      setCurrentBall(null)\n    }\n    setGridDesignerOpen(false)\n  }\n\n  // toggle dab for a specific cell (manual)\n  const toggleDab = (r, c) => {\n    // if dab overlay is not active/initialized, ignore manual toggles\n    if (!dabbed) return\n    setDabbed(prev => {\n      const copy = prev.map(row => row.slice())\n      copy[r][c] = !copy[r][c]\n      return copy\n    })\n  }\n\n  // When a number is called, mark any matching numbers on the card as dabbed (auto)\n  const handleNumberCalled = useCallback((num, { auto } = { auto: false }) => {\n    setCalled(prev => {\n      const next = [...prev, num]\n      return next\n    })\n    setCurrentBall(num)\n    if (auto && dabbed) {\n      setDabbed(prev => {\n        const copy = prev.map(row => row.slice())\n        for (let r = 0; r < card.length; r++) {\n          for (let c = 0; c < (card[r] || []).length; c++) {\n            if (String(card[r][c]) === String(num)) copy[r][c] = true\n          }\n        }\n        return copy\n      })\n    }\n  }, [card, dabbed])\n\n  // On any dab change, check for full-row wins\n  useEffect(() => {\n    if (!dabbed) return\n    // check rows\n    for (let r = 0; r < dabbed.length; r++) {\n      const row = dabbed[r]\n      const all = row.every(Boolean)\n      if (all) {\n        const player = grid?.playerOverlay?.rows?.[r]\n        setWinner({ axis: 'row', index: r, player })\n        fireConfetti()\n        return\n      }\n    }\n    // check columns\n    const cols = dabbed[0]?.length || 0\n    for (let c = 0; c < cols; c++) {\n      let all = true\n      for (let r = 0; r < dabbed.length; r++) {\n        if (!dabbed[r][c]) { all = false; break }\n      }\n      if (all) {\n        const player = grid?.playerOverlay?.cols?.[c]\n        setWinner({ axis: 'col', index: c, player })\n        fireConfetti()\n        return\n      }\n    }\n  }, [dabbed, grid])\n\n  const resetGame = () => {\n    setCalled([])\n    setCurrentBall(null)\n    if (dabbed) setDabbed(prev => prev.map(row => row.map(() => false)))\n    setWinner(null)\n  }\n\n  const toggleDabLine = (axis, idx) => {\n    // ignore if dab overlay not present\n    if (!dabbed) return\n    setDabbed(prev => {\n      const copy = prev.map(r=>r.slice())\n      if (axis === 'row') {\n        const all = copy[idx].every(Boolean)\n        for (let c=0;c<copy[idx].length;c++) copy[idx][c] = !all\n      } else {\n        // col\n        const rows = copy.length\n        let all = true\n        for (let r=0;r<rows;r++) if(!copy[r][idx]) { all = false; break }\n        for (let r=0;r<rows;r++) copy[r][idx] = !all\n      }\n      return copy\n    })\n  }\n\n  return (\n    <div className=\"app-root\">\n      <header className=\"topbar\">\n        <h1>Custom Bingo</h1>\n      </header>\n      <main className=\"main\">\n        <section className=\"left\">\n          <ImageUploader onResult={setCardFromOCR} />\n          <DabOverlayControls grid={grid} defaults={gridDefaults} setDefaults={setGridDefaults} onDesign={openGridDesigner} onClear={clearGrid} playersRows={playersRows} setPlayersRows={setPlayersRows} playersCols={playersCols} setPlayersCols={setPlayersCols} />\n          <PlayerList playersRows={playersRows} setPlayersRows={setPlayersRows} playersCols={playersCols} setPlayersCols={setPlayersCols} showRows={gridDefaults?.showPlayerRows} setShowRows={(v)=>setGridDefaults(d=>({ ...d, showPlayerRows: v }))} showCols={gridDefaults?.showPlayerCols} setShowCols={(v)=>setGridDefaults(d=>({ ...d, showPlayerCols: v }))} />\n          <BallPicker\n            maxBall={settings.maxBall}\n            setMaxBall={(v) => setSettings(s => ({ ...s, maxBall: v }))}\n            autoMode={settings.autoMode}\n            setAutoMode={(v) => setSettings(s => ({ ...s, autoMode: v }))}\n            called={called}\n            onCall={(num) => handleNumberCalled(num, { auto: settings.autoMode })}\n            resetGame={resetGame}\n            currentBall={currentBall}\n          />\n          {gridDesignerOpen && (\n            <GridDesigner imageUrl={displayImageUrl} initialGrid={grid} initialDefaults={gridDefaults} onSave={saveGrid} onCancel={closeGridDesigner} playersRows={playersRows} setPlayersRows={setPlayersRows} playersCols={playersCols} setPlayersCols={setPlayersCols} />\n          )}\n        </section>\n        <section className=\"right\">\n          <CardView\n            card={card}\n            playersRows={playersRows}\n            setPlayersRows={setPlayersRows}\n            playersCols={playersCols}\n            setPlayersCols={setPlayersCols}\n            dabbed={dabbed}\n            onToggleDab={toggleDab}\n            onToggleDabLine={toggleDabLine}\n            manualMode={!settings.autoMode}\n            setCard={setCard}\n            setDabbed={setDabbed}\n            imageUrl={displayImageUrl}\n            grid={grid}\n          />\n        </section>\n      </main>\n      <WinModal\n        open={winner !== null}\n        onClose={() => setWinner(null)}\n        winner={winner}\n      />\n    </div>\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}